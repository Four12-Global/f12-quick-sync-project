This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
quick-sync-plugin/
  modules/
    author-sync.php
    books-sync.php
    leaders-sync.php
    series-sync.php
    sessions-sync.php
    worship-sync.php
  core-helpers.php
  f12-quick-sync.php
  module-base.php
  README.md
  relations.php
quick-sync-scripts/
  src/
    lib/
      media-helpers.ts
      sync-helpers.ts
    author-media.ts
    author-sync.ts
    books-media.ts
    books-sync.ts
    series-media.ts
    series-sync.ts
    sessions-media.ts
    sessions-sync.ts
    worship-media.ts
    worship-sync.ts
  env.d.ts
  package.json
  README.md
  tsconfig.json
.gitattributes
.gitignore
airtable-fields.md
package.json
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="quick-sync-plugin/modules/author-sync.php">
<?php
/**
 * Quick Sync Module: Author/Speaker Taxonomy (Production Ready)
 *
 * This module syncs data from Airtable to the 'author_speaker' WordPress taxonomy.
 *
 * Features:
 * - Implements a "whitelist" for meta fields to ensure data integrity and prevent database pollution.
 * - Unknown meta keys from the payload are logged and ignored, not stored.
 * - Restores the robust `wp_id` -> `SKU` -> `slug` lookup chain for de-duplication.
 * - Only deletes meta on explicit `null` values to prevent accidental data loss.
 * - Integrates Parsedown to convert Markdown bios to safe HTML.
 * - Provides detailed logging and includes warnings in the API response for ignored fields.
 */

if ( ! defined( 'ABSPATH' ) ) {
    exit; // Exit if accessed directly.
}


class F12_Author_Speaker_Sync_Module {

    // --- Configuration ---
    private $endpoint_slug = 'author-sync';
    private $taxonomy = 'author_speaker';
    private $sku_meta_key = 'sku';

    /**
     * @var array A whitelist of meta keys allowed to be synced from the payload.
     * All other meta keys will be logged as a warning and ignored.
     */
    private $allowed_meta_keys = [
        'profile_image',
        'status',
        // Add other known, valid meta keys here as your schema evolves.
        // e.g., 'author_twitter_handle', 'author_linkedin_url'
    ];
    
    /**
     * Public getter for the main plugin router.
     * @return string The slug for the REST API endpoint (e.g., 'author-sync').
     */
    public function get_endpoint_slug() {
        return $this->endpoint_slug;
    }

    /**
     * Public getter for the main plugin router to define API arguments.
     * @return array Standard argument definitions for the REST endpoint.
     */
    public function get_rest_api_args() {
        return [
            'sku' => [
                'type'              => 'string',
                'required'          => true,
                'sanitize_callback' => 'sanitize_text_field',
                'description'       => 'Unique identifier (SKU) for the Author/Speaker term.',
            ],
            'fields' => [
                'type'              => 'object',
                'required'          => true,
                'description'       => 'Object containing all term data fields.',
            ],
            'wp_id' => [
                'type'              => 'integer',
                'required'          => false,
                'sanitize_callback' => 'absint',
                'description'       => 'WordPress Term ID for fast-path updates.',
            ],
            'airtableRecordId' => [
                'type'              => 'string',
                'required'          => false,
                'sanitize_callback' => 'sanitize_text_field',
                'description'       => 'Optional Airtable Record ID for logging.',
            ],
        ];
    }
    
    /**
     * The main handler for the sync request.
     */
    public function handle_sync_request( WP_REST_Request $request ) {
        $json_params = $request->get_json_params();

        // --- 1. Validate Payload ---
        $sku = isset( $json_params['sku'] ) ? sanitize_text_field( $json_params['sku'] ) : null;
        $payload = isset( $json_params['fields'] ) ? (array) $json_params['fields'] : null;
        $wp_id = isset( $json_params['wp_id'] ) ? absint( $json_params['wp_id'] ) : 0;
        
        if ( empty($sku) || empty($payload) || empty($payload['name']) ) {
             return new WP_Error('f12_invalid_author_payload', 'Request requires a top-level SKU and a fields object containing at least a "name".', ['status' => 400]);
        }
        
        // --- 2. Find Existing Term ---
        $existing_term = $this->find_existing_term($sku, $payload, $wp_id);
        $mode = $existing_term ? 'update' : 'create';
        
        // --- 3. Prepare Core Term Data ---
        $name = sanitize_text_field($payload['name']);
        $slug = isset($payload['slug']) ? sanitize_title($payload['slug']) : sanitize_title($name);
        // Prefer as_description, then description, then empty string
        $raw_description = $payload['as_description'] ?? $payload['description'] ?? '';
        if (isset($payload['as_description']) && is_string($payload['as_description']) && class_exists('Parsedown')) {
            $description = wp_kses_post(Parsedown::instance()->setSafeMode(true)->text($payload['as_description']));
        } else {
            $description = is_string($raw_description) ? $raw_description : '';
        }
        // Build term_data WITHOUT 'description'
        $term_data = [
            'slug' => $slug,
        ];

        // --- 4. Create or Update Term ---
        if ('update' === $mode) {
            $result = wp_update_term($existing_term->term_id, $this->taxonomy, $term_data);
            $term_id = is_wp_error($result) ? 0 : $existing_term->term_id;
        } else {
            $result = wp_insert_term($name, $this->taxonomy, $term_data);
            $term_id = is_wp_error($result) ? 0 : (int) $result['term_id'];
        }

        // --- Save the rich-text HTML into term-meta (as_description) ---
        if ($term_id) {
            $current = get_term_meta($term_id, 'as_description', true);
            if ($current !== $description) {
                update_term_meta($term_id, 'as_description', wp_kses_post($description));
            }
        }

        if (is_wp_error($result) || $term_id === 0) {
            $error_message = is_wp_error($result) ? $result->get_error_message() : 'Term could not be created or updated.';
            return new WP_Error('f12_term_save_failed', $error_message, ['status' => 500]);
        }

        // --- 5. Process Meta Fields (using the Whitelist approach) ---
        $this->process_meta_fields($term_id, $sku, $payload, $ignored_keys_for_response);
        
        // --- 6. Return Success Response ---
        $response_data = [
            'term_id' => $term_id,
            'action'  => $mode,
            'sku'     => $sku,
            'message' => sprintf('Author/Speaker term (ID: %d) %s successfully.', $term_id, $mode),
        ];

        if (!empty($ignored_keys_for_response)) {
            $response_data['warnings'] = [
                'ignored_meta_keys' => array_unique($ignored_keys_for_response)
            ];
        }

        return rest_ensure_response($response_data);
    }
    
    /**
     * Finds an existing term using the robust `wp_id` -> `SKU` -> `slug` lookup chain.
     *
     * @param string $sku The unique SKU for the term.
     * @param array $payload The incoming fields payload, used to get the slug.
     * @param int $wp_id The WordPress Term ID, if provided.
     * @return WP_Term|null The found term object or null.
     */
    private function find_existing_term($sku, $payload, $wp_id) {
        // 1. Fast-path: Check provided Term ID first.
        if ($wp_id > 0) {
            $term = get_term($wp_id, $this->taxonomy);
            if ($term && !is_wp_error($term) && get_term_meta($term->term_id, $this->sku_meta_key, true) === $sku) {
                f12_sync_log(sprintf('[AuthorSync] Term found via fast-path wp_id: %d', $wp_id));
                return $term;
            }
        }
        
        // 2. Primary lookup: Find by SKU meta key.
        $terms = get_terms([
            'taxonomy'   => $this->taxonomy,
            'hide_empty' => false,
            'number'     => 1,
            'meta_query' => [['key' => $this->sku_meta_key, 'value' => $sku]],
        ]);
        if (!empty($terms) && !is_wp_error($terms)) {
            f12_sync_log(sprintf('[AuthorSync] Term found via SKU meta: %s', $sku));
            return $terms[0];
        }
        
        // 3. Fallback: Find by slug (for claiming manually created terms).
        $slug_to_check = isset($payload['slug']) ? $payload['slug'] : (isset($payload['name']) ? $payload['name'] : '');
        if (!empty($slug_to_check)) {
            $slug = sanitize_title($slug_to_check);
            $term = get_term_by('slug', $slug, $this->taxonomy);
            if ($term && !is_wp_error($term)) {
                $existing_sku = get_term_meta($term->term_id, $this->sku_meta_key, true);
                if (empty($existing_sku)) {
                    f12_sync_log(sprintf('[AuthorSync] Term found via SLUG FALLBACK: %s. Claiming it for SKU %s.', $slug, $sku));
                    return $term;
                }
            }
        }
        
        return null; // Term not found
    }

    /**
     * Safely processes meta fields based on the whitelist.
     *
     * @param int $term_id The ID of the term to update.
     * @param string $sku The SKU of the term, for special handling.
     * @param array $payload The incoming fields payload.
     * @param array &$ignored_keys_for_response A reference to an array to store warnings.
     */
    private function process_meta_fields($term_id, $sku, $payload, &$ignored_keys_for_response = []) {
        // Always ensure the SKU meta is set correctly.
        update_term_meta($term_id, $this->sku_meta_key, $sku);
        
        // These keys were handled as core properties and should not be processed as meta.
        $handled_core_keys = ['name', 'slug', 'as_description'];
        
        foreach ($payload as $meta_key => $meta_value) {
            // Skip keys that are core properties or the SKU itself.
            if (in_array($meta_key, $handled_core_keys, true) || $meta_key === $this->sku_meta_key) {
                continue;
            }

            $meta_key_sanitized = sanitize_key($meta_key);

            // --- THE WHITELIST GATE ---
            if (!in_array($meta_key_sanitized, $this->allowed_meta_keys, true)) {
                f12_sync_log(sprintf('[AuthorSync] Ignored unknown meta key "%s" for term ID %d. Not in allowed list.', $meta_key_sanitized, $term_id));
                $ignored_keys_for_response[] = $meta_key_sanitized;
                continue; // Skip rogue key
            }

            // --- SAFE META HANDLING (for whitelisted keys only) ---
            if ($meta_value === null) {
                // Explicitly delete meta if the payload sends null.
                delete_term_meta($term_id, $meta_key_sanitized);
                f12_sync_log(sprintf('[AuthorSync] Deleted meta key "%s" for term ID %d due to null value.', $meta_key_sanitized, $term_id));
            } else {
                // Update meta for any other value.
                update_term_meta($term_id, $meta_key_sanitized, $meta_value);
            }
        }
    }
}
</file>

<file path="quick-sync-plugin/modules/books-sync.php">
<?php
/**
 * Quick Sync Module: Books CPT
 *
 * Provides the specific configuration for syncing the 'books' Custom Post Type.
 * It inherits all universal processing logic (post lookup, media sideloading,
 * AIOSEO integration, etc.) from the F12_Quick_Sync_Module_Base class.
 */

if ( ! defined( 'ABSPATH' ) ) {
    exit; // Exit if accessed directly.
}

class F12_Books_Sync_Module extends F12_Quick_Sync_Module_Base {

    /**
     * Set up all configuration for the 'books' CPT.
     * This function maps the incoming payload from the Airtable script to the correct
     * WordPress fields, taxonomies, and meta keys.
     */
    protected function init() {
        // --- 1. Core Configuration ---
        // Defines the CPT slug, the API endpoint, and the SKU meta key.
        $this->cpt = 'books'; // The slug for your "Books" Custom Post Type in WordPress.
        $this->endpoint_slug = 'books-sync'; // Must match the endpoint in books-sync.ts.
        $this->sku_meta_key = 'sku'; // The meta key used to store the unique SKU.

        // --- 2. Core Field Mapping ---
        // Maps payload keys to core WordPress post fields (in the wp_posts table).
        $this->core_field_map = [
            'post_title'   => 'post_title',
            'post_name'    => 'post_name',
            'post_excerpt' => 'post_excerpt',
            'post_status'  => 'post_status',
            'post_date'    => 'post_date',
        ];

        // --- 3. Taxonomy Mapping ---
        // Maps a payload key to a WordPress taxonomy slug. The base class
        // will automatically find or create the terms and assign them to the post.
        $this->taxonomy_map = [
            // Payload Key      => WordPress Taxonomy Slug
            'global-categories' => 'global-categories',
            'topics'            => 'topics',
            'author'            => 'author', // Assumes you have a custom 'author' taxonomy.
        ];

        // --- 4. Image/Media Meta Mapping ---
        // Lists meta keys that correspond to media. If the payload for one of these
        // keys contains a URL instead of a WP Media ID, the base class will
        // automatically download the file and save the new attachment ID.
        $this->image_meta_map = [
            '_thumbnail_id', // The featured image.
            'pdf-image-1',   // The custom image for the PDF link.
        ];

        // --- 5. Markdown Mapping (Optional but Recommended) ---
        // Tells the base class to treat the incoming 'post_content' field as
        // Markdown, convert it to safe HTML, and save it to the post's content.
        $this->markdown_map = [
            // Payload Key    => Destination(s) in WordPress
            'post_content' => ['post_content'],
        ];
        
        // --- NO NEED TO LIST OTHER META FIELDS ---
        // All other fields from your payload (like 'tag-line', 'link_five',
        // 'version-1-title', etc.) will be automatically saved as post meta
        // by the base class. You do not need to declare them here.
    }

    // No other methods are needed. The F12_Quick_Sync_Module_Base handles everything else.
}
</file>

<file path="quick-sync-plugin/core-helpers.php">
<?php

if ( ! defined( 'ABSPATH' ) ) {
    exit; // Exit if accessed directly.
}

/**
 * Centralized permission check for all sync endpoints.
 * Relies on WordPress Application Passwords.
 */
function f12_quick_sync_permission_check( WP_REST_Request $request ) {
    if ( ! current_user_can( 'edit_posts' ) ) {
        return new WP_Error(
            'rest_forbidden',
            __( 'You do not have permission to perform this action.', 'f12-quick-sync' ),
            [ 'status' => 403 ]
        );
    }
    return true;
}

/**
 * Logs messages to the PHP error log if WP_DEBUG and WP_DEBUG_LOG are enabled.
 */
function f12_sync_log( $message ) {
    if ( defined( 'WP_DEBUG' ) && WP_DEBUG === true && defined( 'WP_DEBUG_LOG' ) && WP_DEBUG_LOG === true ) {
        $prefix = '[Four12 Quick Sync] ';
        if ( is_array( $message ) || is_object( $message ) ) {
            error_log( $prefix . print_r( $message, true ) );
        } else {
            error_log( $prefix . $message );
        }
    }
}

/**
 * Retrieves a single post object by its SKU meta field.
 *
 * @param string $sku The SKU to search for.
 * @param string $cpt The post type to search within.
 * @param string $sku_meta_key The meta key for the SKU.
 * @return WP_Post|null The found WP_Post object or null if not found.
 */
function f12_get_post_by_sku( $sku, $cpt, $sku_meta_key ) {
    if ( empty( $sku ) || empty($cpt) || empty($sku_meta_key) ) {
        return null;
    }
    $query_args = [
        'post_type'      => $cpt,
        'post_status'    => 'any',
        'posts_per_page' => 1,
        'meta_query'     => [
            [
                'key'   => $sku_meta_key,
                'value' => $sku,
            ],
        ],
        'fields'         => '', // Return full post objects
    ];
    $posts = get_posts( $query_args );

    if ( ! empty( $posts ) ) {
        if ( count( $posts ) > 1 ) {
            f12_sync_log( sprintf( 'Warning: Duplicate SKU "%s" detected in CPT "%s". Found %d posts. Returning the first one (ID: %d).', esc_html( $sku ), $cpt, count( $posts ), $posts[0]->ID ) );
        }
        return $posts[0];
    }
    return null;
}

/**
 * Sideloads an image from a URL into the WordPress Media Library.
 *
 * @param string $image_url The URL of the image to sideload.
 * @param int    $post_id   The ID of the post to attach the image to (0 for unattached).
 * @param string $desc      Description for the image media item (optional).
 * @return int|WP_Error Attachment ID on success, WP_Error on failure.
 */
function f12_sideload_image_from_url( $image_url, $post_id = 0, $desc = null ) {
    if ( empty( $image_url ) || ! filter_var( $image_url, FILTER_VALIDATE_URL ) ) {
        return new WP_Error( 'invalid_image_url', __( 'Invalid image URL provided for sideloading.', 'f12-quick-sync' ), $image_url );
    }

    if ( ! function_exists( 'media_handle_sideload' ) ) {
        require_once ABSPATH . 'wp-admin/includes/media.php';
        require_once ABSPATH . 'wp-admin/includes/file.php';
        require_once ABSPATH . 'wp-admin/includes/image.php';
    }

    $tmp = download_url( $image_url );
    if ( is_wp_error( $tmp ) ) {
        @unlink( $tmp );
        return new WP_Error( 'image_download_failed', sprintf( __( 'Could not download image from URL: %s. Error: %s', 'f12-quick-sync' ), esc_url($image_url), $tmp->get_error_message() ), $tmp->get_error_data() );
    }

    $file_array = [
        'name'     => basename( strtok( $image_url, '?' ) ),
        'tmp_name' => $tmp,
    ];

    if ( is_wp_error( $file_array['tmp_name'] ) ) {
        @unlink( $file_array['tmp_name'] );
        return new WP_Error( 'image_temp_store_failed', __( 'Could not store temporary image file after download.', 'f12-quick-sync' ), $file_array['tmp_name'] );
    }

    $attachment_id = media_handle_sideload( $file_array, $post_id, $desc );
    
    @unlink( $file_array['tmp_name'] );

    if ( is_wp_error( $attachment_id ) ) {
        return new WP_Error( 'image_sideload_failed', sprintf( __( 'Could not sideload image. Error: %s', 'f12-quick-sync' ), $attachment_id->get_error_message() ), $attachment_id->get_error_data() );
    }

    return (int) $attachment_id;
}

/**
 * Returns "now" as DateTime in the siteâ€™s timezone.
 */
function f12qs_now(): DateTime {
    return new DateTime( 'now', wp_timezone() ); // site tz
}

/** Local â€œMySQLâ€ string â€“ what WP expects for post_date */
function f12qs_mysql_local( DateTime $dt ): string {
    return $dt->format( 'Y-m-d H:i:s' );
}

/** UTC â€œMySQLâ€ string â€“ what WP expects for post_date_gmt */
function f12qs_mysql_gmt( DateTime $dt ): string {
    $utc = clone $dt;
    $utc->setTimezone( new DateTimeZone( 'UTC' ) );
    return $utc->format( 'Y-m-d H:i:s' );
}

/** Pure UTC Unix timestamp â€“ what JetEngine wants when â€œSave as timestampâ€ */
function f12qs_unix_utc( DateTime $dt ): int {
    $utc = clone $dt;
    $utc->setTimezone( new DateTimeZone( 'UTC' ) );
    return $utc->getTimestamp();
}
</file>

<file path="quick-sync-scripts/src/author-sync.ts">
// quick-sync-scripts/src/author-sync.ts

import { quickSync, QuickSyncConfig, FieldMap } from './lib/sync-helpers';

// This is the single, valid call to input.config() for the entire script run.
const scriptInput = input.config();

// This FIELD_MAP is taken directly from your v1 script.
// This is the most important part! We map to 'name' and 'slug', not 'post_title'.
const AUTHOR_FIELD_MAP: FieldMap = {
  // Airtable Field Name  ->  WP Payload Key for a TAXONOMY TERM
  'author_title':       'name',
  'author_slug':        'slug',
  'author_description': 'as_description', // Your PHP plugin handles this
  'profile_image_wp_id':'profile_image',  // This is just a meta field for the term

  // Special case: The SKU is both a meta field and a top-level payload key.
  // The helper automatically promotes the 'sku' value to the top level.
  'sku':                'sku',
};

const authorSyncConfig: QuickSyncConfig = {
  // Airtable table name
  airtableTable: 'author-speaker',

  // The unique identifier fields in Airtable
  skuField: 'sku',
  titleField: 'author_title', // Used for logging and fallback naming

  // Your field map
  fieldMap: AUTHOR_FIELD_MAP,

  // Your endpoints
  envEndpoints: {
    prod: 'https://four12global.com/wp-json/four12/v1/author-sync',
    staging: 'https://wordpress-1204105-5660147.cloudwaysapps.com/wp-json/four12/v1/author-sync' 
  },
};

// Pass the scriptInput object to the helper function.
quickSync(authorSyncConfig, scriptInput);
</file>

<file path="quick-sync-scripts/src/books-media.ts">
// src/books-media.ts

import { mediaSync, MediaSyncConfig } from './lib/media-helpers';

// The single, valid call to input.config() for the entire script run.
const scriptInput = input.config();

const booksMediaConfig: MediaSyncConfig = {
  // 1. The name of your Airtable table
  airtableTable: 'Books',

  // 2. The standard WordPress media endpoints for production and staging
  envMediaEndpoints: {
    prod:    'https://four12global.com/wp-json/wp/v2/media',
    staging: 'https://wordpress-1204105-5660147.cloudwaysapps.com/wp-json/wp/v2/media',
  },

  // 3. Airtable fields used to track when a media sync is needed
  lastModifiedField:     'media_last_modified',
  publishTimestampField: 'media_publish_timestamp',

  // 4. A list of all image/attachment fields for the "Books" CPT
  imageFields: [
    // Configuration for the main featured image
    {
      attachmentField:    'featured_image_attachment',
      wpIdField:          'featured_image_wp_id',
      wpUrlField:         'featured_image_link',
      airtableCacheField: 'featured_image_external',
      isMultiple:         false,
    },
    // Configuration for the custom PDF's preview image
    {
      attachmentField:    'pdf_image_1_attachment',
      wpIdField:          'pdf_image_1_wp_id',
      wpUrlField:         'pdf_image_1_link',
      airtableCacheField: 'pdf_image_1_external',
      isMultiple:         false,
    },
  ],
};

// This one line runs the entire media sync process using the configuration above.
mediaSync(booksMediaConfig, scriptInput);
</file>

<file path="quick-sync-scripts/src/books-sync.ts">
// src/books-sync.ts

import { quickSync, QuickSyncConfig, FieldMap } from './lib/sync-helpers';

// The single, valid call to input.config() for the entire script run.
const scriptInput = input.config();

// The FIELD_MAP is the heart of the configuration.
// It maps the 'Airtable Field Name' to the 'WordPress Payload Key'.
const FIELD_MAP: FieldMap = {
  /* --- Core WordPress Fields --- */
  'title': 'post_title',
  'slug': 'post_name',
  'content': 'post_content',
  'excerpt': 'post_excerpt',
  'status': 'post_status',
  'post_date': 'post_date',

  /* --- SKU (Essential for de-duplication) --- */
  'sku': 'sku',

  /* --- SEO & Permalinks --- */
  '_aioseo_description': '_aioseo_description',
  'Custom URI': 'custom_permalink_uri', // For Permalink Manager plugin

  /* --- Taxonomies --- */
  'global_categories': 'global-categories',
  'author': 'author', // Maps to 'author' taxonomy
  'topics': 'topics',

  /* --- Media Fields (using the IDs from the media script) --- */
  'featured_image': {
    airtableIdField:   'featured_image_wp_id',
    airtableLinkField: 'featured_image_link',
    wpKey: '_thumbnail_id', // Special WP key for the featured image
  },
  'pdf_image_1': {
    airtableIdField:   'pdf_image_1_wp_id',
    airtableLinkField: 'pdf_image_1_link',
    wpKey: 'pdf-image-1', // A custom meta field for the PDF's image
  },

  /* --- Custom Meta Fields (Links & Content) --- */
  'tag-line': 'tag-line',
  'link_five - Print PDF Link': 'link_five',
  'link_twelve - Hardcopy Link': 'link_twelve',
  'link_six - Web PDF Link': 'link_six',
  'link_eight - Kindle PDF Link': 'link_eight',
  'link_thirteen - Order Here': 'link_thirteen',
  'custom-pdf-title-1': 'custom-pdf-title-1',
  'link_ten - Custom PDF Link 1': 'link_ten',

  /* --- Version 1 Content (as custom meta) --- */
  'version-1-title': 'version-1-title',
  'version-1-tag-line': 'version-1-tag-line',
  'version-1-content': 'version-1-content',
  'version-1-footer': 'version-1-footer',

  /* --- Timestamps (for bookkeeping) --- */
  'last_synced': 'last_synced',
  'publish_timestamp': 'last_published',
};

const booksSyncConfig: QuickSyncConfig = {
  // The name of your Airtable table
  airtableTable: 'Books',

  // The Airtable fields holding the unique ID and title
  skuField: 'sku',
  titleField: 'title',

  // The field map defined above
  fieldMap: FIELD_MAP,

  // The WordPress endpoints for this CPT
  // NOTE: You will need to create a 'books-sync.php' module in your WP plugin
  // to create this endpoint.
  envEndpoints: {
    prod:    'https://four12global.com/wp-json/four12/v1/books-sync',
    staging: 'https://wordpress-1204105-5660147.cloudwaysapps.com/wp-json/four12/v1/books-sync',
  },
};

// This one line runs the entire data sync process.
quickSync(booksSyncConfig, scriptInput);
</file>

<file path="quick-sync-scripts/src/sessions-media.ts">
// src/sessions-media.ts

import { mediaSync, MediaSyncConfig } from './lib/media-helpers';

// The single, valid call to input.config()
const scriptInput = input.config();

const sessionsMediaConfig: MediaSyncConfig = {
  // 1. Your Airtable table name
  airtableTable: 'Sessions',

  // 2. WP Media endpoints per environment
  envMediaEndpoints: {
    prod:    'https://four12global.com/wp-json/wp/v2/media',
    staging: 'https://wordpress-1204105-5660147.cloudwaysapps.com/wp-json/wp/v2/media',
  },

  // 3. Fields that track media-related updates
  lastModifiedField:     'media_last_modified',
  publishTimestampField: 'media_publish_timestamp',

  // 4. One entry per image slot in the CPT
  imageFields: [
    {
      attachmentField:    'featured_image_attachment',
      wpIdField:          'featured_image_wp_id',
      wpUrlField:         'featured_image_link',
      airtableCacheField: 'featured_image_external',
      isMultiple:         false,
    },
    {
      attachmentField:    'banner_image_attachment',
      wpIdField:          'banner_image_wp_id',
      wpUrlField:         'banner_image_link',
      airtableCacheField: 'banner_image_external',
      isMultiple:         false,
    },
    {
      attachmentField:    'listing_image_attachment',
      wpIdField:          'listing_image_wp_id',
      wpUrlField:         'listing_image_link',
      airtableCacheField: 'listing_image_external',
      isMultiple:         false,
    },
    {
      attachmentField:    'no_words_image_attachment',
      wpIdField:          'no_words_image_wp_id',
      wpUrlField:         'no_words_image_link',
      airtableCacheField: 'no_words_image_external',
      isMultiple:         false,
    },
    {
      attachmentField:    'pdf_image_1_attachment',
      wpIdField:          'pdf_image_1_wp_id',
      wpUrlField:         'pdf_image_1_link',
      airtableCacheField: 'pdf_image_1_external',
      isMultiple:         false,
    },
    {
      attachmentField:    'pdf_image_2_attachment',
      wpIdField:          'pdf_image_2_wp_id',
      wpUrlField:         'pdf_image_2_link',
      airtableCacheField: 'pdf_image_2_external',
      isMultiple:         false,
    },
  ],
};

// Fire it off
mediaSync(sessionsMediaConfig, scriptInput);
</file>

<file path="quick-sync-scripts/src/worship-media.ts">
// quick-sync-scripts/src/worship-media.ts

import { mediaSync, MediaSyncConfig } from './lib/media-helpers';

// The single, valid call to input.config() for the entire script run.
const scriptInput = input.config();

const worshipMediaConfig: MediaSyncConfig = {
  // 1. Your Airtable table name
  airtableTable: 'Worship',

  // 2. WP Media endpoints (these are standard and rarely change)
  envMediaEndpoints: {
    prod: 'https://four12global.com/wp-json/wp/v2/media',
    staging: 'https://wordpress-1204105-5660147.cloudwaysapps.com/wp-json/wp/v2/media',
  },

  // 3. The fields you use in Airtable to track media changes
  lastModifiedField: 'media_last_modified',
  publishTimestampField: 'media_publish_timestamp',

  // 4. One entry for each media attachment field in your CPT
  imageFields: [
    // Entry for the Featured Image
    {
      attachmentField:    'featured_image_attachment',
      wpIdField:          'featured_image_wp_id',
      wpUrlField:         'featured_image_link',
      airtableCacheField: 'featured_image_external',
      isMultiple:         false,
    },
    // Entry for the Chord Sheet PDF
    {
      attachmentField:    'chord_sheet_attachment',
      wpIdField:          'chord_sheet_wp_id',
      wpUrlField:         'chord_sheet_link',
      airtableCacheField: 'chord_sheet_external',
      isMultiple:         false, // It's a single PDF attachment
    },
  ],
};

// Pass the scriptInput object to the helper function to run the sync.
mediaSync(worshipMediaConfig, scriptInput);
</file>

<file path="quick-sync-scripts/env.d.ts">
// Airtable scripting globals (injected at runtime)
declare const input:  any;
declare const output: any;
declare const base:   any;
</file>

<file path="quick-sync-scripts/tsconfig.json">
{
    "compilerOptions": {
      "target": "es2017",
      "lib": ["es2017", "dom"],
      "module": "commonjs",
      "strict": true,
      "esModuleInterop": true,
      "outDir": "dist"
    },
    "include": ["src/**/*", "env.d.ts"]
  }
</file>

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path=".gitignore">
# Dependencies
/node_modules
/quick-sync-plugin/vendor

# Build output
/quick-sync-scripts/dist

# Tool-specific generated files
**/repomix-output.xml

# Log files
*.log
debug.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# OS / Editor specific
.DS_Store
Thumbs.db
.vscode/
.idea/
</file>

<file path="airtable-fields.md">
# Airtable Resources Base - Common Fields Analysis

## Overview
This document analyzes the common fields across all tables in the Resources Base to identify standard fields that should be included when creating new tables. These fields are not content-specific but rather provide consistent structure, tracking, and functionality across all resources.

## Base Information
- **Base Name**: Resources Base
- **Base ID**: `apphmPNiTdmcknmfs`
- **Total Tables**: 15

## Tables Analyzed
1. Series
2. Sessions
3. Articles
4. News
5. Series_2
6. Sessions_2
7. author-speaker
8. Topics
9. Leaders
10. Worship
11. Books
12. Ministry
13. subsplash_resource_lists
14. subsplash_list_rows
15. series_type

## Standard Fields for New Tables

### 1. Core Identification Fields
These fields provide unique identification and basic metadata for each record:

| Field Name | Field Type | Description | Example | WordPress Mapping |
|------------|------------|-------------|---------|-------------------|
| `auto_number` | AutoNumber | Auto-incrementing unique identifier | 1, 2, 3... | N/A |
| `sku` | Formula | Unique SKU code (usually based on auto_number) | "S0001", "R0001", "A0001" | `sku` |
| `id` | Number | WordPress ID or external system ID | 12345 | N/A |
| `title` / `name` | SingleLineText/MultilineText | Primary title/name of the resource | "Series Title" | `post_title` |

### 2. URL and Permalink Fields
These fields handle web routing and SEO:

| Field Name | Field Type | Description | Example | WordPress Mapping |
|------------|------------|-------------|---------|-------------------|
| `slug` | Formula/SingleLineText | URL-friendly version of title | "series-title" | `post_name` |
| `permalink` | URL/Formula | Full URL path | "/resources/series/series-title" | `custom_permalink_uri` |

### 3. Content Management Fields
These fields handle content status and workflow:

| Field Name | Field Type | Description | Example | WordPress Mapping |
|------------|------------|-------------|---------|-------------------|
| `website_status` | SingleSelect | Publication status | "publish", "draft", "private" | `post_status` |
| `excerpt` | MultilineText | Short description/summary | "Brief description..." | `post_excerpt` |
| `content` / `description` | MultilineText | Main content body | "Full content..." | Custom meta |
| `content_admin` | RichText | Admin-only content | "Internal notes..." | Custom meta |

### 4. Timestamp Tracking Fields
These fields provide comprehensive tracking of when content was created, modified, and published:

| Field Name | Field Type | Description | Example | WordPress Mapping |
|------------|------------|-------------|---------|-------------------|
| `last_modified` | LastModifiedTime | When any field was last changed | Auto-generated | N/A |
| `media_last_modified` | LastModifiedTime | When media fields were last changed | Auto-generated | N/A |
| `admin_last_modified` | LastModifiedTime | When admin fields were last changed | Auto-generated | N/A |
| `publish_timestamp` | DateTime | When content was published | 2024-01-15 10:00:00 | `last_published` |
| `media_publish_timestamp` | DateTime | When media was published | 2024-01-15 10:00:00 | N/A |
| `admin_publish_timestamp` | DateTime | When admin content was published | 2024-01-15 10:00:00 | N/A |

### 5. Status and Workflow Fields
These fields provide status indicators and workflow management:

| Field Name | Field Type | Description | Example | WordPress Mapping |
|------------|------------|-------------|---------|-------------------|
| `update_status` | Formula | Human-readable update status | "âš¡ Just Updated", "ðŸš€ Updated Today" | N/A |
| `publish_status` | Formula | Publication readiness status | "âœ… Ready", "ðŸŽ¯ Needs Publish" | N/A |
| `sync_status` | SingleSelect | External system sync status | "Success", "Processing", "Failed" | N/A |
| `import_status` | SingleLineText | Import process status | "Completed", "Pending" | N/A |

### 6. Media Management Fields
These fields handle images and media assets. **Note: Use the `_wp_id` variant for WordPress sync:**

| Field Name | Field Type | Description | Example | WordPress Mapping |
|------------|------------|-------------|---------|-------------------|
| `featured_image_wp_id` | Number | WordPress media ID (preferred) | 12345 | `_thumbnail_id` |
| `featured_image_link` | URL | Featured image URL (fallback) | "https://example.com/image.jpg" | Custom meta |
| `featured_image_attachment` | MultipleAttachments | Featured image file | Image file | N/A |
| `featured_image_external` | SingleLineText | External image reference | "external_image_id" | N/A |
| `listing_image_wp_id` | Number | WordPress media ID for listing | 12346 | `listing-image` |
| `listing_image_link` | URL | Listing image URL | "https://example.com/listing.jpg" | Custom meta |
| `banner_image_wp_id` | Number | WordPress media ID for banner | 12347 | `banner-image` |
| `banner_image_link` | URL | Banner image URL | "https://example.com/banner.jpg" | Custom meta |
| `no_words_image_wp_id` | Number | WordPress media ID (no text) | 12348 | `no-words-image` |
| `no_words_image_link` | URL | No-text image URL | "https://example.com/nowords.jpg" | Custom meta |

### 7. Category and Classification Fields
These fields provide content organization and navigation:

| Field Name | Field Type | Description | Example | WordPress Mapping |
|------------|------------|-------------|---------|-------------------|
| `category_helper` | SingleLineText | Raw category string | "Resources>Series>Youth" | N/A |
| `category` | SingleLineText | Processed category | "Youth" | Custom taxonomy |
| `category_1`, `category_2`, etc. | Formula | Individual category levels | "Resources", "Series" | N/A |
| `global_categories` | Formula | Full category hierarchy | "Resources > Series > Youth" | `global-categories` |
| `series_category` | SingleSelect | Predefined category options | "Featured Messages" | `series-categories` |

### 8. Relationship Fields
These fields connect content to other resources:

| Field Name | Field Type | Description | Example | WordPress Mapping |
|------------|------------|-------------|---------|-------------------|
| `series` | MultipleRecordLinks | Related series | Links to Series table | `jet_relation_series_parent` |
| `series_sku` | MultipleLookupValues | Series SKU from relationship | "S0001" | `jet_relation_series_parent` |
| `sessions` | MultipleRecordLinks | Related sessions | Links to Sessions table | Custom meta |
| `topics` | MultipleRecordLinks | Related topics | Links to Topics table | `topics` |
| `author` / `speaker` | MultipleRecordLinks | Content creators | Links to author-speaker table | `author-speaker` |

### 9. External Integration Fields
These fields handle connections to external systems:

| Field Name | Field Type | Description | Example | WordPress Mapping |
|------------|------------|-------------|---------|-------------------|
| `wp_id` | Number | WordPress ID | 12345 | N/A |
| `subsplash_*` | Various | Subsplash platform fields | Various Subsplash-specific fields | Custom meta |

### 10. SEO and Metadata Fields
These fields handle search engine optimization:

| Field Name | Field Type | Description | Example | WordPress Mapping |
|------------|------------|-------------|---------|-------------------|
| `seo_description` | Formula/MultilineText | SEO meta description | "SEO description..." | Custom meta |
| `_aioseo_description` | MultilineText | All in One SEO description | "AIOSEO description..." | `_aioseo_description` |
| `aioseo_description` | SingleLineText | Alternative SEO description | "Alternative SEO..." | Custom meta |

### 11. Additional Content Fields
These fields provide extra content and functionality:

| Field Name | Field Type | Description | Example | WordPress Mapping |
|------------|------------|-------------|---------|-------------------|
| `pdf_title_1` | SingleSelect | PDF document title | "Worksheet", "Discussion Pages" | `custom-pdf-title-1` |
| `pdf_link_1` | SingleLineText | PDF document link | "https://example.com/doc.pdf" | `link_ten` |
| `youtube_link` | URL | YouTube video link | "https://youtube.com/watch?v=..." | `link_one` |
| `spotify_podcast` | URL | Spotify podcast link | "https://open.spotify.com/..." | `spotify-podcast-link` |
| `apple_podcast` | URL | Apple Podcasts link | "https://podcasts.apple.com/..." | `apple-podcast-link` |

## Recommended Field Order for New Tables

When creating a new table, consider this field order:

1. **Core Identification** (auto_number, sku, id, title)
2. **Content** (excerpt, content, content_admin)
3. **URLs** (slug, permalink)
4. **Categories** (category_helper, category, global_categories)
5. **Media** (featured_image_wp_id, listing_image_wp_id, banner_image_wp_id, no_words_image_wp_id)
6. **Relationships** (series, sessions, topics, author)
7. **Timestamps** (last_modified, media_last_modified, admin_last_modified)
8. **Publishing** (publish_timestamp, media_publish_timestamp, admin_publish_timestamp, api_publish_timestamp)
9. **Status** (website_status, update_status, publish_status, sync_status)
10. **External IDs** (wp_id, subsplash_*)
11. **SEO** (seo_description, _aioseo_description)
12. **Additional Content** (pdf_*, youtube_link, spotify_podcast, apple_podcast)

## Field Type Recommendations

- Use **Formula** fields for computed values (SKUs, status indicators, derived fields)
- Use **LastModifiedTime** for automatic timestamp tracking
- Use **MultipleAttachments** for file uploads
- Use **MultipleRecordLinks** for relationships to other tables
- Use **SingleSelect** for predefined options (status, categories)
- Use **DateTime** for manual timestamp entry
- Use **URL** for external links
- Use **RichText** for admin content that needs formatting
- Use **Number** for WordPress media IDs and external IDs

## WordPress Integration Notes

### **Media Field Pattern:**
Always create both the `_wp_id` and `_link` variants for media fields:
- `featured_image_wp_id` (Number) â†’ WordPress `_thumbnail_id`
- `featured_image_link` (URL) â†’ Fallback/cache field

### **Taxonomy Mapping:**
- `global_categories` â†’ WordPress `global-categories` taxonomy
- `topics` â†’ WordPress `topics` taxonomy
- `author-speaker` â†’ WordPress `author-speaker` taxonomy

### **Custom Meta Fields:**
- Use descriptive names that match WordPress meta keys
- Consider using the `link_*` pattern for external resources
- Use `custom-*` prefix for custom content fields

## Notes

- **SKU Pattern**: Most tables use a letter prefix + 4-digit number (S0001, R0001, A0001, etc.)
- **Timestamp Consistency**: All tables use the same timestamp field structure for consistency
- **Media Handling**: Standardized approach with wp_id fields for WordPress sync, link fields for fallbacks
- **Category Structure**: Hierarchical category system with helper fields and derived category levels
- **Status Workflow**: Consistent status tracking across all content types
- **WordPress Sync**: Fields are designed to map directly to WordPress post types and taxonomies

This analysis provides a foundation for maintaining consistency when creating new tables in the Resources Base while ensuring all necessary functionality is preserved and proper WordPress integration is maintained.
</file>

<file path="package.json">
{
  "devDependencies": {
    "typescript": "^5.8.3"
  }
}
</file>

<file path="quick-sync-plugin/modules/leaders-sync.php">
<?php
/**
 * Quick Sync Module: Leaders CPT (f12-leaders)
 *
 * Provides the specific configuration for syncing the 'f12-leaders' Custom Post Type.
 * This module includes special handling to parse a Markdown description into HTML.
 */

if ( ! defined( 'ABSPATH' ) ) {
    exit; // Exit if accessed directly.
}

class F12_Leader_Sync_Module extends F12_Quick_Sync_Module_Base {

    /**
     * Set up all configuration for the 'f12-leaders' CPT.
     */
    protected function init() {
        // --- 1. Core Configuration ---
        $this->cpt = 'f12-leaders';
        $this->endpoint_slug = 'leader-sync';
        $this->sku_meta_key = 'leader_sku';

        // --- 2. Field Mapping (Payload Key => WP Destination) ---
        $this->core_field_map = [
            'post_title'   => 'post_title',
            'post_excerpt' => 'post_excerpt', // Airtable 'leader_description' is mapped here.
        ];

        $this->taxonomy_map = [
            'leadership-role' => 'leadership-role',
        ];

        $this->image_meta_map = [
            '_thumbnail_id',
        ];


		// Markdown mapping configuration
		$this->markdown_map = [
			'leader_description' => ['leader_description']
		];
    }

    /**
     * Override the special meta processing hook to handle Markdown conversion.
     */
    protected function _process_special_meta_fields( $post_id, &$payload, $sku, &$changed_summary ) {
        // Check if the 'leader_description' field exists in the payload.
        if ( array_key_exists( 'leader_description', $payload ) ) {
            
            $raw_markdown = $payload['leader_description'];
            $html_output = '';

            // Ensure Parsedown is available and the value is a non-empty string.
            if ( class_exists('Parsedown') && is_string($raw_markdown) && !empty($raw_markdown) ) {
                // Convert Markdown to safe HTML.
                $html_output = wp_kses_post( Parsedown::instance()->setSafeMode(true)->text($raw_markdown) );
                f12_sync_log(sprintf('[LeaderSync] Parsed Markdown for leader_description on post ID %d.', $post_id));
            } else {
                // If it's not a string or Parsedown is missing, just sanitize it.
                $html_output = is_string($raw_markdown) ? wp_kses_post($raw_markdown) : '';
            }

            // Update the meta field with the processed HTML.
            update_post_meta($post_id, 'leader_description', $html_output);

            // IMPORTANT: Unset the key from the payload so the base class
            // doesn't process it a second time as a generic meta field.
            unset($payload['leader_description']);

            // Log the change for the response summary.
            if ( ! in_array( 'leader_description (Markdown parsed)', $changed_summary['special'] ) ) {
                $changed_summary['special'][] = 'leader_description (Markdown parsed)';
            }
        }
    }
}
</file>

<file path="quick-sync-plugin/modules/series-sync.php">
<?php
/**
 * Quick Sync Module: Series CPT
 *
 * Provides the specific configuration for syncing the 'series' Custom Post Type.
 * It inherits all universal processing logic (Timezone, AIOSEO, etc.)
 * from the F12_Quick_Sync_Module_Base class.
 */

if ( ! defined( 'ABSPATH' ) ) {
    exit; // Exit if accessed directly.
}

class F12_Series_Sync_Module extends F12_Quick_Sync_Module_Base {

    /**
     * Set up all configuration for the 'series' CPT.
     */
    protected function init() {
        // --- Core Configuration ---
        $this->cpt = 'series';
        $this->endpoint_slug = 'series-sync';
        $this->sku_meta_key = 'sku';

        // --- Field Mapping ---
        $this->core_field_map = [
            'post_title'   => 'post_title',
            'post_name'    => 'post_name',
            'post_excerpt' => 'post_excerpt',
            'post_date'    => 'post_date',
            'post_status'  => 'post_status',
        ];

        $this->taxonomy_map = [
            'global-categories' => 'global-categories',
            'series-categories' => 'series-categories',
            'topics'            => 'topics',
            'series-templates'  => 'series-templates',
        ];

        $this->image_meta_map = [
            '_thumbnail_id',
            'listing-image',
            'no-words-image',
            'banner-image',
            'manual1-image',
        ];

        // Markdown mapping configuration
        $this->markdown_map = [
            'series_description' => ['post_content', 'series_description']
        ];
    }

    // No other methods are needed here. The timezone and AIOSEO logic
    // are now handled automatically by the base class.
}
</file>

<file path="quick-sync-scripts/src/lib/sync-helpers.ts">
/*********************************************************************
 * sync-helpers.ts  â€“  shared utilities for Quick-Sync scripts
 * ---------------------------------------------------------------
 * Usage in a table-specific entry file (e.g. series-sync.ts):
 *
 *   import { quickSync } from './lib/sync-helpers';
 *
 *   quickSync({
 *     airtableTable: 'Series',
 *     fieldMap: FIELD_MAP,
 *     envEndpoints: {
 *       prod:    'https://four12global.com/wp-json/four12/v1/series-sync',
 *       staging: 'https://wordpress-1204105-5660147.cloudwaysapps.com/wp-json/four12/v1/series-sync',
 *
 *     },
 *   });
 *********************************************************************/

/* =========  Types  ========= */
export interface MediaSpec {
  airtableIdField: string;
  airtableLinkField?: string;
  wpKey: string;
}
export type FieldMap = Record<
  string,
  string | MediaSpec
>;

export interface QuickSyncConfig {
  airtableTable: string;
  fieldMap: FieldMap;
  envEndpoints: Record<string, string>;
  skuField:   string;
  titleField: string;
  allowedStatuses?: string[];
  secretName?:      string;
}


/* =========  Console helper ========= */
const log = (msg: unknown) =>
  console.log(`[${new Date().toISOString()}]`, msg);

/* =========  Common constants ========= */
const DEFAULT_ALLOWED_STATUSES = ['publish', 'draft', 'trash', 'private'];
const DEFAULT_SECRET_NAME      = 'API-SYNC';
const LAST_SYNCED_KEY          = 'last_synced';

/* =========  Auth helper ========= */
export function buildBasicAuth(secret: string, secretName = DEFAULT_SECRET_NAME) {
  if (!secret || !secret.includes(':'))
    throw new Error(`Secret "${secretName}" must be "user:app-password".`);
  return Buffer.from(secret).toString('base64');
}

/* =========  Airtable field utils ========= */
export function fieldsToFetch(
  map: FieldMap,
  skuField: string,
  titleField: string,
): string[] {
  const s = new Set<string>();
  for (const k in map) {
    const v = map[k];
    if (typeof v === 'string') s.add(k);
    else {
      s.add(v.airtableIdField);
      if (v.airtableLinkField) s.add(v.airtableLinkField);
    }
  }
  s.add('wp_id').add(skuField).add(titleField);
  return Array.from(s);
}

/* Clean & coerce values so WP gets primitives */
export function coerceValue(field: string, raw: any): any {
  if (raw == null) return null;

  // multiselects, linked records, lookups â†’ array â‡¢ names/strings
  if (Array.isArray(raw)) {
    return raw.map(x =>
      (typeof x === 'object' && x !== null && 'name' in x)
        ? x.name
        : String(x)
    );
  }

  // single attachment â†’ url
  if (typeof raw === 'object' && raw.url)
    return raw.url;

  // single-select object â†’ name
  if (typeof raw === 'object' && raw !== null && 'name' in raw)
    return raw.name;

  return raw; // plain string/number/date already fine
}

/* Build WP `fields` object */
export function buildSyncFields(record: any, map: FieldMap): Record<string, any> {
  const table = record.parentTable;         // Airtable API
  const fields: Record<string, any> = {};

  for (const src in map) {
    const mapping = map[src];

    // Simple 1â‡¢1 mapping
    if (typeof mapping === 'string') {
      const raw = record.getCellValue(src);
      if (mapping === 'post_status') {
        // status handled later (allowedStatuses check)
        fields.post_status = raw && raw.name ? raw.name.toLowerCase() :
                             typeof raw === 'string' ? raw.toLowerCase() : null;
      } else {
        fields[mapping] = coerceValue(src, raw);
      }
      continue;
    }

    // Media object
    const val = record.getCellValue(mapping.airtableIdField) ||
                (mapping.airtableLinkField && record.getCellValue(mapping.airtableLinkField));
    if (val) fields[mapping.wpKey] = val;
  }

  return fields;
}

/* =========  WP fetch helper ========= */
export async function postToWp(
  url: string,
  authB64: string,
  payload: any
) {
  const res = await fetch(url, {
    method:  'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization:  `Basic ${authB64}`,
    },
    body: JSON.stringify(payload),
  });
  const text = await res.text();
  if (!res.ok) {
    // Even on error, it's useful to return the status
    throw new Error(`HTTP ${res.status}: ${text.slice(0, 500)}`);
  }
  
  // Return an object with both the parsed data and the status code
  return {
    data: JSON.parse(text),
    status: res.status
  };
}

/* =========  Main orchestrator ========= */
export async function quickSync(cfg: QuickSyncConfig, inputConfig: any) {
  const {
    airtableTable,
    fieldMap,
    envEndpoints,
    skuField,
    titleField,
    allowedStatuses = DEFAULT_ALLOWED_STATUSES,
    secretName     = DEFAULT_SECRET_NAME,
  } = cfg;
  if (!skuField || !titleField)
    throw new Error('quickSync: skuField and titleField are required');

  // Use the passed-in inputConfig object
  const { recordId, env } = inputConfig;
  if (!recordId) throw new Error('Automation must pass {recordId}.');
  if (!env || !envEndpoints[env]) {
    const availableEnvs = Object.keys(envEndpoints).join(', ');
    throw new Error(`Input variable "env" is missing or invalid. Please provide one of the following: ${availableEnvs}`);
  }
  const wpUrl = envEndpoints[env];

  const syncEpoch = Math.floor(Date.now() / 1000);
  log(`Quick-Sync (${airtableTable}) start â€“ epoch ${syncEpoch}`);

  /* â”€â”€ Auth â”€â”€ */
  const authSecret = await input.secret(secretName);
  const authB64    = buildBasicAuth(authSecret, secretName);

  /* â”€â”€ Fetch record â”€â”€ */
  const table  = base.getTable(airtableTable);
  const fieldsNeeded = fieldsToFetch(fieldMap, skuField, titleField);
  const record = await table.selectRecordAsync(recordId, { fields: fieldsNeeded });
  if (!record) throw new Error(`Record ${recordId} not found in ${airtableTable}`);

  /* â”€â”€ Build fields â”€â”€ */
  const fields = buildSyncFields(record, fieldMap);

// Ensure SKU & title exist
fields.sku ??= record.getCellValueAsString(skuField);

// Get the destination key for the title from the field map (e.g., 'post_title' or 'name')
const titleDestinationKey = (typeof fieldMap[titleField] === 'string')
  ? fieldMap[titleField] as string
  : null;

// Only add the title if its destination key is known and it's not already set.
if (titleDestinationKey) {
    fields[titleDestinationKey] ??= record.getCellValueAsString(titleField) || record.name;
}

fields[LAST_SYNCED_KEY] = syncEpoch;

// We still need the title for logging purposes, regardless of its key
const titleForLogging = (titleDestinationKey && fields[titleDestinationKey])
    ? fields[titleDestinationKey]
    : record.getCellValueAsString(titleField) || record.name;

  // post_status whitelist
  if (fields.post_status && !allowedStatuses.includes(fields.post_status))
    delete fields.post_status;

  /* â”€â”€ Assemble payload â”€â”€ */
  const payload = {
    airtableRecordId: record.id,
    sku:   fields.sku,
    wp_id: record.getCellValue('wp_id') || null,
    fields,
  };
  console.log(JSON.stringify(payload, null, 2).substring(0, 5000));
  output.set(
    'payloadSent',
    JSON.stringify(payload, null, 2).slice(0, 2500)
  );

  
/* â”€â”€ POST to WP â”€â”€ */
log(`POSTing to ${wpUrl}`);
// Use destructuring to get both `data` and `status` from the response
const { data, status } = await postToWp(wpUrl, authB64, payload);

/* â”€â”€ Handle response â”€â”€ */
const postId = data.term_id ?? data.post_id ?? data?.data?.post_id;
const action   = data.action  ?? 'unknown';
const message  = data.message ?? '';

output.set(
  'syncStatus',
  // Use the `status` variable we just received
  data && postId ? 'Success' : `HTTP_${status}`
);
output.set('action',     action);
output.set('message',    message);
output.set('postTitle',  titleForLogging);
output.set('wpPostId',   postId ?? null);
log(`âœ… WP ${action} â€“  ${titleForLogging}`);
}
</file>

<file path="quick-sync-scripts/src/author-media.ts">
// quick-sync-scripts/src/author-media.ts

import { mediaSync, MediaSyncConfig } from './lib/media-helpers';

// This config object replaces all the hardcoded constants in the old script.
const authorMediaConfig: MediaSyncConfig = {
  // 1. Your Airtable table name
  airtableTable: 'author-speaker',

  // 2. WP Media endpoints per environment
  envMediaEndpoints: {
    prod: 'https://four12global.com/wp-json/wp/v2/media',
    staging: 'https://wordpress-1204105-5660147.cloudwaysapps.com/wp-json/wp/v2/media',
  },

  // 3. The fields you use to track media changes
  lastModifiedField: 'media_last_modified',
  publishTimestampField: 'media_publish_timestamp',

  // 4. One entry for the profile image
  //    This directly maps to the IMAGE_FIELDS from your old script.
  imageFields: [
    {
      attachmentField:    'profile_image_attachment',
      wpIdField:          'profile_image_wp_id',
      wpUrlField:         'profile_image_link',
      airtableCacheField: 'profile_image_external',
      isMultiple:         false, // This is a single image field
    },
  ],
};

// The single, valid call to input.config() for the entire script run.
const scriptInput = input.config();

// This one line runs the entire sync process using the config above.
mediaSync(authorMediaConfig, scriptInput);
</file>

<file path="quick-sync-scripts/src/series-media.ts">
// src/series-media.ts

import { mediaSync, MediaSyncConfig } from './lib/media-helpers';

// The single, valid call to input.config()
const scriptInput = input.config();

const seriesMediaConfig: MediaSyncConfig = {
  // 1. Your Airtable table name
  airtableTable: 'Series',

  // 2. WP Media endpoints per environment
  envMediaEndpoints: {
    prod: 'https://four12global.com/wp-json/wp/v2/media',
    staging: 'https://wordpress-1204105-5660147.cloudwaysapps.com//wp-json/wp/v2/media',
  },

  // 3. The fields you use in Airtable to track media changes
  lastModifiedField:     'media_last_modified',
  publishTimestampField: 'media_publish_timestamp',

  // 4. One entry per image slot in your CPT
  imageFields: [
    {
      attachmentField:    'featured_image_attachment',
      wpIdField:          'featured_image_wp_id',
      wpUrlField:         'featured_image_link',
      airtableCacheField: 'featured_image_external',
      isMultiple:         false,
    },
    {
      attachmentField:    'banner_image_attachment',
      wpIdField:          'banner_image_wp_id',
      wpUrlField:         'banner_image_link',
      airtableCacheField: 'banner_image_external',
      isMultiple:         false,
    },
    {
      attachmentField:    'listing_image_attachment',
      wpIdField:          'listing_image_wp_id',
      wpUrlField:         'listing_image_link',
      airtableCacheField: 'listing_image_external',
      isMultiple:         false,
    },
    {
      attachmentField:    'no_words_image_attachment',
      wpIdField:          'no_words_image_wp_id',
      wpUrlField:         'no_words_image_link',
      airtableCacheField: 'no_words_image_external',
      isMultiple:         false,
    },
    {
      attachmentField:    'primary_cta_image_attachment',
      wpIdField:          'primary_cta_image_wp_id',
      wpUrlField:         'primary_cta_image_link',
      airtableCacheField: 'primary_cta_image_external',
      isMultiple:         false,
    },
  ],
};

// Pass the scriptInput object to the helper function.
mediaSync(seriesMediaConfig, scriptInput);
</file>

<file path="quick-sync-scripts/src/series-sync.ts">
import { quickSync } from './lib/sync-helpers';

const FIELD_MAP = {
  /* â”€â”€ Core WP fields â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  series_title:      'post_title',
  series_slug:       'post_name',
  long_date:         'post_date',
  website_status:    'post_status',
  series_sku:        'sku',
  excerpt:           'post_excerpt',

  /* Custom permalink (Permalink Manager) */
  series_permalink:  'custom_permalink_uri',

  /* â”€â”€ Taxonomies â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  global_categories:      'global-categories',
  series_filter_category: 'series-categories',
  topics:                 'topics',
  series_template:        'series-templates',

  /* â”€â”€ ACTIVE media (prefer ID, fallback URL) â”€â”€â”€â”€ */
  featured_image: {
    airtableIdField:   'featured_image_wp_id',
    airtableLinkField: 'featured_image_link',
    wpKey: '_thumbnail_id',
  },
  listing_image: {
    airtableIdField:   'listing_image_wp_id',
    airtableLinkField: 'listing_image_link',
    wpKey: 'listing-image',
  },
  no_words_image: {
    airtableIdField:   'no_words_image_wp_id',
    airtableLinkField: 'no_words_image_link',
    wpKey: 'no-words-image',
  },
  banner_image: {
    airtableIdField:   'banner_image_wp_id',
    airtableLinkField: 'banner_image_link',
    wpKey: 'banner-image',
  },
  primary_cta_image: {
    airtableIdField:   'primary_cta_image_wp_id',
    airtableLinkField: 'primary_cta_image_link',
    wpKey: 'manual1-image',
  },

  /* â”€â”€ Meta / CTA / SEO etc. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  series_description_title: 'series-description_title',
  series_description:       'series-description',
  who_is_it_for:            'series-who-is-it-for',
  series_purpose:           'series-purpose',
  series_colour_1:          'series-colour-1',
  series_colour_2:          'series-colour-2',
  print_pdf_link:           'link_five',
  custom_pdf_link:          'link_ten',
  youtube_playlist:         'youtube-playlist-link',
  spotify_playlist:         'spotify-playlist-link',
  apple_playlist:           'apple-playlist-link',
  highlights_video:         'highlights-video',

  /* CTA blocks */
  primary_cta_heading: 'manual1-title',
  primary_cta_title:   'manual1-link-title',
  primary_cta_link:    'manual1-link',
  secondary_cta_heading: 'manual2-title',
  secondary_cta_title:   'manual2-link-title',
  secondary_cta_link:    'manual2-link',

  seo_description:     '_aioseo_description',
  session_title:       'custom-session-title',
  sessions_list:       'series-episode-list',
  session_list_1:      'series-episode-list-more',
  session_list_2:      'series-episode-list-3',
  session_list_3:      'series-episode-list-4',
};

// The single, valid call to input.config() for the entire script run.
const scriptInput = input.config();

quickSync({
  /* ----- Airtable table name ----- */
  airtableTable: 'Series',

  /* ----- Airtable field that holds your permanent SKU & title ----- */
  skuField:   'series_sku',
  titleField: 'series_title',

  /* ----- END perâ€‘CPT overrides ----- */
  fieldMap: FIELD_MAP,
  envEndpoints: {
    prod:     'https://four12global.com/wp-json/four12/v1/series-sync',
    staging:  'https://wordpress-1204105-5660147.cloudwaysapps.com/wp-json/four12/v1/series-sync',
  }
}, scriptInput);
</file>

<file path="quick-sync-scripts/src/worship-sync.ts">
// quick-sync-scripts/src/worship-sync.ts

import { quickSync, FieldMap } from './lib/sync-helpers';

// This is the single, valid call to input.config() for the entire script run.
const scriptInput = input.config();

// The FIELD_MAP is the heart of the configuration.
// It maps 'Airtable Field Name' to the 'WordPress Payload Key'.
const WORSHIP_FIELD_MAP: FieldMap = {
  /* --- Core WP Fields --- */
  'title': 'post_title',
  'slug': 'post_name',
  'website_status': 'post_status',
  'excerpt': 'post_excerpt',
  'seo_description': '_aioseo_description',
  'release_date': 'post_date',

  /* --- SKU (Essential for de-duplication) --- */
  'sku': 'sku',

  /* Custom permalink (Permalink Manager) */
  permalink:  'custom_permalink_uri',

  /* --- Taxonomy --- */
  // Maps the 'worship_artist' field in Airtable to the 'worship_artist' taxonomy in WordPress.
  'worship_artist': 'worship_artist',
  'topics': 'topics',
  'category': 'global-categories',

  /* --- Media Fields (using the IDs from the media script) --- */
  'featured_image_wp_id': {
    airtableIdField: 'featured_image_wp_id',
    airtableLinkField: 'featured_image_link',
    wpKey: '_thumbnail_id', // This is the special WordPress key for the featured image.
  },

  // 1. Send the ID to a meta field for backend reference
  'chord_sheet_wp_id': { // The Airtable field containing the ID(s)
    airtableIdField: 'chord_sheet_wp_id',
    wpKey: 'chord_sheet_wp_id', // Save it to a WP meta field with the same name
  },

  // 2. Send the URL to a separate meta field for the frontend
  'chord_sheet_link': { // The Airtable field containing the URL(s)
    airtableIdField: 'chord_sheet_link', // Use the link field as the source
    wpKey: 'chord_sheet_link', // Save it to a clear, distinct WP meta field
  },

    /* --- Simple Meta Fields (Links) --- */
    // These will be saved directly as post meta in WordPress.
    'apple_music_link': 'apple_music_link',
    'spotify_link': 'spotify_link',
    'youtube_music_link': 'youtube_music_link',
};

const worshipSyncConfig = {
  /* ----- Airtable table name ----- */
  airtableTable: 'Worship',

  /* ----- Airtable field that holds your permanent SKU & title ----- */
  skuField: 'sku',
  titleField: 'title',
  

  /* ----- Use the field map defined above ----- */
  fieldMap: WORSHIP_FIELD_MAP,

  /* ----- Define the production and staging endpoints for this CPT ----- */
  envEndpoints: {
    prod: 'https://four12global.com/wp-json/four12/v1/worship-sync',
    staging: 'https://wordpress-1204105-5660147.cloudwaysapps.com/wp-json/four12/v1/worship-sync',
  },
};

// Pass the config and input to the helper function to run the sync.
quickSync(worshipSyncConfig, scriptInput);
</file>

<file path="quick-sync-scripts/README.md">
Of course. Here is a comprehensive and well-thought-out `README.md` for the `quick-sync-scripts` directory.

This document replaces the outdated instructions, accurately reflects the modern TypeScript architecture, and provides a clear, step-by-step guide for developers to maintain and extend the Airtable scripts.

---

# Airtable Quick Sync Scripts

This is a TypeScript project that contains all the "client-side" scripts for the Airtable-to-WordPress synchronization system. These scripts run inside Airtable Automations, gather record data, and send it to the `quick-sync-plugin` on the WordPress server.

## Core Architecture

This is not a collection of standalone scripts. It is a modern TypeScript project that must be **compiled** before use. This approach provides significant advantages:

*   **Type Safety:** TypeScript prevents common errors before the code ever runs in Airtable.
*   **Shared Logic:** Common functions for authentication, data handling, and media uploads are centralized in `src/lib/` for consistency and easy updates.
*   **Modularity:** Each CPT or Taxonomy has its own small, clean entry-point file, which is easy to read and manage.
*   **Build Process:** A standardized build process (`npm run build`) minifies the code, making it efficient to paste into Airtable.

```mermaid
flowchart LR
    subgraph "Development (Your Computer)"
        A[src/lib/sync-helpers.ts] --> B[src/series-sync.ts];
        C[src/lib/media-helpers.ts] --> D[src/series-media.ts];
        B & D -- "npm run build" --> E((esbuild Compiler));
    end

    subgraph "Deployment (Airtable)"
        F[dist/series-sync.js];
        G[dist/series-media.js];
        E --> F & G;
        F & G -- "Copy & Paste" --> H{Airtable Automation Scripts};
    end
```

---

## Developer Setup

**Prerequisites:** You must have [Node.js](https://nodejs.org/) and `npm` installed.

1.  **Install Dependencies:** From within this directory (`quick-sync-scripts/`), run:
    ```bash
    npm install
    ```

2.  **Build the Scripts:** To compile all TypeScript files from `src/` into JavaScript files in `dist/`, run:
    ```bash
    npm run build
    ```

3.  **Watch for Changes (Development):** To automatically re-compile whenever you save a file, run:
    ```bash
    npm run watch
    ```

---

## The Two-Step Sync Process

For each record, we use a two-step automation in Airtable to ensure media is handled correctly.

1.  **Media Sync Script:** Runs first. It uploads images/files to WordPress and saves the returned WordPress Media IDs back to the Airtable record.
2.  **Data Sync Script:** Runs second. It sends all the record's text data, taxonomy data, and the stable WordPress Media IDs from Step 1 to the custom endpoint in our plugin.

## How to Add a New Sync Workflow (e.g., for an "Events" CPT)

Follow this two-step process to create the necessary scripts for a new CPT.

### Step 1: Create the Media Script

This script handles the image attachments.

1.  Create a new file in the `src/` directory: `events-media.ts`.
2.  Add the following code, customizing the `eventsMediaConfig` object for your needs.

    ```typescript
    // src/events-media.ts

    import { mediaSync, MediaSyncConfig } from './lib/media-helpers';

    // The single, valid call to input.config() for the entire script run.
    const scriptInput = input.config();

    const eventsMediaConfig: MediaSyncConfig = {
      // 1. The name of your Airtable table
      airtableTable: 'Events',

      // 2. The standard WordPress media endpoints
      envMediaEndpoints: {
        prod:    'https://four12global.com/wp-json/wp/v2/media',
        staging: 'https://wordpress-1204105-5660147.cloudwaysapps.com/wp-json/wp/v2/media',
      },

      // 3. Airtable fields used to track when a sync is needed
      lastModifiedField:     'media_last_modified',     // A "Last Modified Time" field
      publishTimestampField: 'media_publish_timestamp', // A "Date" field (set to "Last Modified")

      // 4. A list of all image/attachment fields for this CPT
      imageFields: [
        {
          attachmentField:    'event_featured_image',    // The attachment field
          wpIdField:          'event_featured_image_wp_id', // A number field for the WP ID
          wpUrlField:         'event_featured_image_link',  // A URL field for the WP URL
          airtableCacheField: 'event_featured_image_ext',   // A text field for the Airtable cache
          isMultiple:         false,
        },
        // Add another object here for the "banner_image", etc.
      ],
    };

    // This one line runs the entire sync process
    mediaSync(eventsMediaConfig, scriptInput);
    ```

### Step 2: Create the Data Script

This script handles all other fields and relationships.

1.  Create a new file in the `src/` directory: `events-sync.ts`.
2.  Add the following code, customizing the `FIELD_MAP` and config object.

    ```typescript
    // src/events-sync.ts

    import { quickSync, QuickSyncConfig, FieldMap } from './lib/sync-helpers';

    // The single, valid call to input.config()
    const scriptInput = input.config();

    // The FIELD_MAP is the heart of the configuration.
    // It maps 'Airtable Field Name' to the 'WordPress Payload Key'.
    const FIELD_MAP: FieldMap = {
      /* --- Core WP Fields --- */
      'event_title':   'post_title',
      'event_slug':    'post_name',
      'event_date':    'post_date',
      'event_status':  'post_status',
      'event_sku':     'sku',

      /* --- Taxonomy Fields --- */
      'event_category': 'event-categories',

      /* --- Media Fields (using the IDs from the media script!) --- */
      'event_featured_image_wp_id': {
        airtableIdField: 'event_featured_image_wp_id', // The field populated by events-media.js
        wpKey: '_thumbnail_id', // The special WordPress key for featured image
      },
    };

    const eventsSyncConfig: QuickSyncConfig = {
      airtableTable: 'Events',
      skuField:      'event_sku',   // The Airtable field holding the unique ID
      titleField:    'event_title', // The Airtable field for the post's title
      fieldMap:      FIELD_MAP,
      envEndpoints: {
        prod:    'https://four12global.com/wp-json/four12/v1/event-sync',
        staging: 'https://wordpress-1204105-5660147.cloudwaysapps.com/wp-json/four12/v1/event-sync',
      },
    };

    // Run the sync process
    quickSync(eventsSyncConfig, scriptInput);
    ```

---

## Deployment to Airtable

The code you write in `src/` is **not** what you paste into Airtable. You must use the compiled output.

1.  **Build the Code:** Run `npm run build` in your terminal. This will create/update the JavaScript files in the `dist/` directory.

2.  **Copy the Script:**
    *   Open the compiled file (e.g., `dist/events-media.js`).
    *   Select all (`Cmd+A` or `Ctrl+A`) and copy the entire contents.

3.  **Paste into Airtable:**
    *   In your Airtable Automation, add a "Run a script" action.
    *   Delete any placeholder code and paste your copied script.

4.  **Configure Inputs:** The scripts require two input variables to be configured in the Airtable UI:
    *   `recordId`: Set its value to the `Airtable record ID` from the automation's trigger step.
    *   `env`: A text string. Type `prod` for your production base or `staging` for your staging base. This allows the script to target the correct WordPress environment.

Repeat this process for the data sync script (`dist/events-sync.js`), ensuring it runs as the next step in the same automation.
</file>

<file path="quick-sync-plugin/modules/worship-sync.php">
<?php
/**
 * Quick Sync Module: Worship CPT
 *
 * Provides the specific configuration for syncing the 'worship' Custom Post Type.
 * It inherits all universal processing logic (post lookup, image handling, etc.)
 * from the F12_Quick_Sync_Module_Base class.
 */

if ( ! defined( 'ABSPATH' ) ) {
    exit; // Exit if accessed directly.
}

class F12_Worship_Sync_Module extends F12_Quick_Sync_Module_Base {

    /**
     * Set up all configuration for the 'worship' CPT.
     * This function maps the incoming payload from Airtable to the correct
     * WordPress fields, taxonomies, and meta keys.
     */
    protected function init() {
        // --- 1. Core Configuration ---
        // Defines the CPT slug, the API endpoint, and the SKU meta key.
        $this->cpt = 'songs';
        $this->endpoint_slug = 'worship-sync';
        $this->sku_meta_key = 'sku'; // Convention: CPT_sku

        // --- 2. Core Field Mapping ---
        // Maps payload keys to core WordPress post fields (wp_posts table).
        $this->core_field_map = [
            'post_title'   => 'post_title',
            'post_name'    => 'post_name',
            'post_excerpt' => 'post_excerpt',
            'post_date'    => 'post_date',
            'post_status'  => 'post_status',
        ];

        // --- 3. Taxonomy Mapping ---
        // Maps a payload key to a WordPress taxonomy slug. The base class
        // will automatically create/assign the terms.
        $this->taxonomy_map = [
            'worship_artist' => 'worship-artist',
            'topics' => 'topics',
            'global-categories' => 'global-categories',
        ];

        // --- 4. Image/Media Meta Mapping ---
        // Lists payload keys that correspond to media. The base class uses this
        // for its URL-sideloading fallback. The primary path (sending a WP ID)
        // is handled by the generic meta processor.
        $this->image_meta_map = [
            '_thumbnail_id',     // The featured image.
            'chord_sheet_pdf',   // The chord sheet PDF.
        ];

        // This CPT does not use markdown or post_content processing.
        
        // Note: The simple meta fields from your Airtable script (`apple_music_link`, 
        // `spotify_link`, `youtube_music_link`, and `chord_sheet_pdf`) do not need
        // to be explicitly defined here. The base class's `_process_meta_fields` 
        // method will automatically handle any remaining keys in the payload and
        // save them as post meta.
    }

    // No other methods are needed. The F12_Quick_Sync_Module_Base handles everything else.
}
</file>

<file path="quick-sync-plugin/README.md">
Excellent. Here is a comprehensive, accurate, and well-structured `README.md` file for the `quick-sync-plugin` directory.

It is written for a developer who needs to understand, maintain, and extend the plugin. It addresses the outdated information from your original README and accurately documents the powerful features you have built.

---

# Four12 Quick Sync Framework

**Version: 2.1.0**
**Author: Four12 Global**

This WordPress plugin provides a modular, configuration-driven framework for syncing data from Airtable. It creates secure REST API endpoints tailored to specific Custom Post Types (CPTs) and Taxonomies, handling the complex logic of data validation, creation, and updating.

## Core Philosophy

*   **Configuration over Code:** Define *what* to sync in a module's configuration arrays, not by writing new processing logic.
*   **Don't Repeat Yourself (DRY):** All shared logic (post lookup, image handling, business rules) lives in central files and is inherited or used by all modules.
*   **Modular & Isolated:** Each sync endpoint is its own class in the `/modules` directory. A bug in one module won't break another.
*   **Two Patterns for Two Jobs:** The framework uses a powerful base class for CPTs and a flexible standalone class pattern for Taxonomies, providing the right tool for each job.

## Installation & Dependencies

1.  Place this plugin folder (`quick-sync-plugin`) in your `wp-content/plugins` directory.
2.  This plugin uses third-party libraries managed by Composer. If the `vendor` directory is missing, you must run `composer install` from within this directory:
    ```bash
    # Navigate to the plugin directory
    cd wp-content/plugins/quick-sync-plugin

    # Install PHP dependencies
    composer install
    ```
3.  Activate the plugin in the WordPress admin panel.

## File Structure Breakdown

The plugin's architecture is designed for clarity and separation of concerns.

```
quick-sync-plugin/
â”‚
â”œâ”€ f12-quick-sync.php        # The Router: Main plugin file that boots the framework and registers all module API routes.
â”œâ”€ core-helpers.php          # The Toolbox: Global helper functions (logging, image sideloading, SKU lookups).
â”œâ”€ module-base.php           # The Engine: An abstract base class containing all shared logic for CPT syncing.
â”œâ”€ relations.php             # The Specialist: A dedicated helper for handling JetEngine relationships.
â””â”€ modules/
     â”œâ”€ series-sync.php      # Example CPT Module: A simple configuration class that extends module-base.php.
     â””â”€ author-sync.php      # Example Taxonomy Module: A standalone class with its own full request logic.
```

## How It Works: The Request Lifecycle

1.  An API request (e.g., `POST /wp-json/four12/v1/sessions-sync`) arrives from an Airtable script.
2.  The **Router** (`f12-quick-sync.php`) matches the endpoint slug (`sessions-sync`) to its corresponding module class (`F12_Sessions_Sync_Module`).
3.  The request is handed off to the module's `handle_sync_request` method.
4.  For CPTs, this method lives in the **Engine** (`module-base.php`). It orchestrates the entire process:
    *   Finds the existing post via `wp_id` or `sku`.
    *   Prepares and saves core post data (`post_title`, `post_date`, etc.).
    *   Processes taxonomies, media, relationships, and all other metadata based on the module's configuration.
5.  A JSON response is sent back to Airtable confirming the `post_id` and the action taken (`created` or `updated`).

---

## Key Features

### Universal Features (All Modules)

*   **SKU-based De-duplication:** A `sku` field is used to reliably find existing items, preventing duplicates.
*   **`wp_id` Fast-Path:** An optional `wp_id` in the payload bypasses the SKU lookup for faster, more efficient updates.
*   **Secure Authentication:** Relies on WordPress Application Passwords for all endpoints.
*   **Robust Post Type Validation:** Returns a `409 Conflict` error if a `wp_id` is provided that belongs to a post of the wrong type, preventing accidental data corruption.

### CPT Module Features (via `module-base.php`)

Any CPT module that extends `F12_Quick_Sync_Module_Base` gets this powerful logic automatically:

*   **Declarative Markdown Parsing:** Simply map an Airtable field to `post_content` (or a meta field) in the `$markdown_map` property, and it will be automatically converted to safe HTML using Parsedown.
*   **AIOSEO Integration:** Payloads containing the `_aioseo_description` key are automatically and safely saved using AIOSEO's models.
*   **Dynamic Taxonomy Handling:** Automatically creates and assigns terms from arrays, comma-separated strings, or hierarchical strings (`Parent > Child`).
*   **Image Sideloading Fallback:** If an image meta key (defined in `$image_meta_map`) contains a URL instead of an ID, the plugin downloads it to the Media Library and saves the new attachment ID.
*   **JetEngine Relationship Sync:** A declarative `$jet_engine_relation_map` allows for effortless syncing of parent-child relationships using SKUs.

---

## How to Add a New Sync Module

### **Pattern 1: Adding a New CPT Sync (e.g., "Events")**

This is the most common pattern. It relies purely on configuration and inherits all logic.

1.  **Create Module File:** Duplicate `modules/series-sync.php` and rename it `modules/events-sync.php`.
2.  **Configure the Class:** Edit the class name and fill in the configuration properties.

    ```php
    <?php
    // modules/events-sync.php

    class F12_Events_Sync_Module extends F12_Quick_Sync_Module_Base {

        protected function init() {
            // --- 1. Core Configuration ---
            $this->cpt = 'event';
            $this->endpoint_slug = 'event-sync';
            $this->sku_meta_key = 'event_sku';

            // --- 2. Field Mapping ---
            $this->core_field_map = [
                // Airtable Payload Key => WordPress Post Field
                'event_title'   => 'post_title',
                'event_date'    => 'post_date',
                'event_status'  => 'post_status',
            ];
            $this->taxonomy_map = [
                'event_type' => 'event-category',
            ];
            $this->image_meta_map = [
                '_thumbnail_id',
                'banner_image',
            ];

            // --- 3. (Optional) Markdown Mapping ---
            $this->markdown_map = [
                // Airtable Field      => Destination(s) in WordPress
                'event_description_md' => ['post_content'],
            ];
        }
    }
    ```
3.  **Done!** The framework automatically discovers the new module and registers the `/wp-json/four12/v1/event-sync` endpoint on the next page load.

### **Pattern 2: Adding a New Taxonomy Sync (e.g., "Topics")**

This pattern provides more granular control for the unique needs of taxonomies (like meta whitelisting).

1.  **Create Module File:** Duplicate `modules/author-sync.php` and rename it `modules/topics-sync.php`.
2.  **Configure the Class:** Edit the class name and update the private configuration properties. The core logic for finding, creating, and updating terms is already present.

    ```php
    <?php
    // modules/topics-sync.php

    class F12_Topics_Sync_Module { // Note: Does NOT extend the base class
        // --- 1. Configuration ---
        private $endpoint_slug = 'topic-sync';
        private $taxonomy = 'topics';
        private $sku_meta_key = 'topic_sku';

        // --- 2. Whitelist your allowed meta keys ---
        private $allowed_meta_keys = [
            'topic_icon_class',
            'is_featured_topic',
        ];

        // The rest of the file (handle_sync_request, find_existing_term, etc.)
        // contains the robust logic for handling taxonomy terms.
    }
    ```
3.  **Done!** The router will register the new `/wp-json/four12/v1/topic-sync` endpoint.

---

## Payload Anatomy

The plugin expects a specific JSON structure from Airtable scripts.

```json
{
  "airtableRecordId": "recXXXXXXXXXXXXXX",
  "sku": "S0123",             // Unique identifier (required)
  "wp_id": 1234,              // WordPress Post/Term ID (optional, for fast updates)
  "fields": {
    /* --- Core Fields (for CPTs) --- */
    "post_title": "My Series Title",
    "post_status": "publish",
    "post_date": "2024-01-01T12:00:00Z",

    /* --- Universal Framework Keys with Special Handling --- */
    "_aioseo_description": "My SEO description.",
    "jet_relation_series_parent": ["PARENT-SKU-001"],

    /* --- Image Fields --- */
    "_thumbnail_id": 567,                 // WP Media ID (preferred)
    "banner-image": "https://.../img.jpg",    // URL (fallback, will be sideloaded)

    /* --- Taxonomy Fields --- */
    "topics": ["Topic A", "Topic B"],
    "series-categories": "Parent > Child"
  }
}
```

## Authentication

Authentication is handled via **WordPress Application Passwords**.

1.  In the WordPress admin, go to **Users > Your Profile**.
2.  Scroll down to "Application Passwords".
3.  Create a new password (e.g., "Airtable Sync").
4.  Copy the generated password (e.g., `abcd efgh ijkl mnop qrst uvwx`).
5.  In your Airtable Automation, create a Secret (e.g., `API-SYNC`) and store your credentials in the format `username:password` (e.g., `my_wp_admin_user:abcd efgh ijkl mnop qrst uvwx`).

## Logging & Debugging

*   **Enable WP_DEBUG:** To see detailed logs, set `WP_DEBUG` and `WP_DEBUG_LOG` to `true` in your `wp-config.php`.
*   **Log Location:** All server-side sync activity is logged to `wp-content/debug.log` with the prefix `[Four12 Quick Sync]`.
*   **What is Logged:** Successes, failures, warnings, ignored meta keys, reasons for skipping a field, and outcomes of third-party integrations.

##Relationships

# 1. The Core Principle: Orchestrator vs. Specialist

The success of this system hinges on a clear separation of concerns between two key files:

- **The Orchestrator (`module-base.php`):** This file is the "manager." It knows *what* needs to be done but not the low-level details of *how*. Its responsibilities are:
    - To parse the incoming API payload.
    - To identify that a relationship needs to be updated (by seeing the `jet_relation_series_parent` key).
    - To extract the necessary information (the child's ID and the parent's SKU).
    - To delegate the actual relationship work to a specialist.
- **The Specialist (`relations.php`):** This file is the "expert." It knows the specific, multi-step process of interacting with the JetEngine API. Its responsibilities are:
    - To accept high-level instructions (e.g., "link this child to this parent SKU").
    - To perform all the necessary lookups (finding the parent post by SKU).
    - To execute the precise, sequential commands required by the JetEngine API (`get_active_relations`, `set_update_context`, `update`).
    - To handle all API-specific logic, keeping the orchestrator clean.

This architecture ensures that if the JetEngine API ever changes, we only need to update the "specialist" (`relations.php`), leaving the "orchestrator" (`module-base.php`) untouched.

---

## 2. End-to-End Data Flow

Here is the step-by-step journey of a relationship sync from Airtable to the WordPress database:

1. **Airtable (`QuickSync Script`):** A JSON payload is constructed. The child post's SKU is the top-level `sku`, and the parent post's SKU is placed in an array within the `fields` object (e.g., `"jet_relation_series_parent": ["S0099"]`).
2. **WordPress (`f12-quick-sync.php`):** The main plugin file receives the POST request. It acts as a router, directing the request to the correct module handler based on the endpoint slug (e.g., `/sessions-sync` routes to `F12_Sessions_Sync_Module`).
3. **The Module (`modules/sessions-sync.php`):** This file provides the **configuration**. It tells the framework that the payload key `jet_relation_series_parent` corresponds to JetEngine `relation_id: 63` and that the parent lives in the `series` CPT.
4. **The Orchestrator (`module-base.php`):** The `handle_sync_request` method begins processing. After creating/updating the core post, it calls the `_process_jet_engine_relations` method. This method:
    - Finds the `jet_relation_series_parent` key in the payload.
    - Extracts the parent SKU (`S0099`).
    - Calls the high-level specialist function `f12_set_relation_parent_by_sku()`, passing it the child's ID, the parent's SKU, and the relation configuration.
5. **The Specialist (`relations.php`):** The `f12_set_relation_parent_by_sku()` function executes the core logic:
    - It uses the helper `f12_get_post_by_sku()` to find the parent post's ID (e.g., `326588`) from its SKU (`S0099`).
    - It gets the JetEngine relation object using `jet_engine()->relations->get_active_relations(63)`.
    - **CRITICAL STEP:** It calls `$rel->set_update_context('child')`. This tells JetEngine, "The action I'm about to perform is from the child's perspective. You should **replace** any existing parents for this child with the one I'm about to provide."
    - It calls `$rel->update(326588, 334333)`, passing the parent ID and child ID as single integers.
6. **The Database (`wp_postmeta`):** Because the "Register separate DB table" setting is OFF for this relation, JetEngine saves the link by creating/updating a row in the `wp_postmeta` table where `post_id` is the child's ID, `meta_key` is `jet_engine_relation_series_resources`, and `meta_value` is the parent's ID.

## 3. Component Breakdown

All of these pieces must work together:

- **`modules/sessions-sync.php` (The Configuration):** Defines the `jet_engine_relation_map`. Without this, the framework wouldn't know what to do with the `jet_relation_series_parent` payload key.
- **`module-base.php` (The Orchestrator):** The `_process_jet_engine_relations` method reads the configuration and delegates the task.
- **`relations.php` (The Specialist):** Contains the `f12_set_relation_parent_by_sku` function that knows how to talk to the JetEngine API.
- **`f12-quick-sync.php` (The Loader):** The `plugins_loaded` action hook at the bottom correctly checks for `function_exists('f12_set_relation_parent_by_sku')` before including `relations.php`. This ensures the specialist is available when the orchestrator needs it.
- **`core-helpers.php` (The Foundation):** Provides the essential `f12_get_post_by_sku()` function, which is critical for converting the parent's SKU into a usable WordPress Post ID.
</file>

<file path="quick-sync-plugin/relations.php">
<?php
// relations.php  (v3.1 - Production Final)

if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

/**
 * Sets the parent for a child post using the parent's SKU.
 * This is a high-level function that encapsulates the entire process of
 * finding the parent, setting the relation context, and updating the link.
 * It will REPLACE any existing parent for the child in this relation.
 *
 * @param int   $child_id         The ID of the child post.
 * @param string $parent_sku      The SKU of the parent post to link.
 * @param array  $relation_config The configuration array from the module's map.
 * @return true|WP_Error
 */
function f12_set_relation_parent_by_sku( int $child_id, string $parent_sku, array $relation_config ) {
    
    // 1. Find the parent post by its SKU.
    $parent_post = f12_get_post_by_sku( $parent_sku, $relation_config['parent_cpt'], $relation_config['parent_sku_meta'] );

    if ( ! $parent_post ) {
        f12_sync_log("[JetEngine] FAILED: Parent post with SKU '{$parent_sku}' not found.");
        return new WP_Error('parent_not_found', "Parent post with SKU '{$parent_sku}' not found.");
    }
    $parent_id = $parent_post->ID;

    // 2. Get the relation object from JetEngine.
    $rel_id = (int) $relation_config['relation_id'];
    $rel = jet_engine()->relations->get_active_relations( $rel_id );

    if ( ! $rel ) {
        f12_sync_log("[JetEngine] FAILED: Relation object for ID '{$rel_id}' not found or is inactive.");
        return new WP_Error('relation_not_found', "JetEngine Relation '{$rel_id}' not found.");
    }

    // 3. Set the context and update the relationship. This is the critical sequence.
    $rel->set_update_context( 'child' );
    $rel->update( $parent_id, $child_id );

    f12_sync_log("[JetEngine] SUCCESS: Linked child ID {$child_id} to parent ID {$parent_id} for relation {$rel_id}.");

    return true;
}
</file>

<file path="quick-sync-scripts/package.json">
{
  "name": "f12-quick-sync",
  "version": "1.0.0",
  "description": "Airtable â†’ WordPress Quick-Sync scripts",
  "type": "module",
  "repository": {
    "type": "git",
    "url": "https://github.com/Four12-Global/f12-quick-sync-project.git"
  },
  "scripts": {
    "check": "tsc --noEmit",
    "build": "esbuild src/*.ts --bundle --format=iife --target=es2017 --minify --outdir=dist",
    "watch": "esbuild src/*.ts --bundle --format=iife --target=es2017 --outdir=dist --watch"
  },
  "devDependencies": {
    "@types/node": "^20.11.0",
    "esbuild": "^0.25.8",
    "typescript": "^5.8.3"
  }
}
</file>

<file path="README.md">
Four12 Quick Sync â€” WordPress Plugin (quick-sync-plugin)

A modular REST layer that receives clean payloads from Airtable (or any upstream) and writes to WordPress posts, taxonomies, media, and JetEngine relationships â€” safely and idempotently.

â¸»

### What this plugin does (in plain English)
*	Registers REST endpoints under `four12/v1/*` (one per content module).
*	Authenticates via WordPress Application Passwords (service account recommended).
*	Resolves target records by `wp_id` â†’ `sku` â†’ `slug` (sane, predictable).
*	Transforms on the server only (markdown â†’ HTML, media sideloading, AIOSEO, custom permalinks).
*	Writes content to WP post fields, meta, taxonomies, and JetEngine relationships.
*	Stays safe by default: nothing is deleted unless you explicitly send `null`.

**TL;DR**: You send a small, declarative JSON payload. The plugin does the heavy lifting and keeps your site tidy.

â¸»

### Requirements & optional integrations
*	WordPress with a user that can `edit_posts` (service user recommended).
*	Application Passwords (WordPress core) for auth.
*	**Optional but supported**
*	Parsedown (`vendor/parsedown/Parsedown.php`) â€” markdown â†’ HTML. If not present, markdown features are skipped.
*	Permalink Manager â€” supports `custom_permalink_uri` for deterministic URLs.
*	JetEngine (Relations) â€” used to link child/parent content (e.g., Session â†’ Series).
*	All in One SEO (AIOSEO) â€” first-class handling for `_aioseo_description`.

â¸»

### Install
1.	Copy the `quick-sync-plugin` folder into `wp-content/plugins/`.
2.	Activate **Four12 â€“ Quick Sync Framework** in Plugins.
3.	(Optional) Drop Parsedown into `quick-sync-plugin/vendor/parsedown/Parsedown.php`.
4.	(Optional) Ensure Permalink Manager and/or JetEngine are active if you use those features.

â¸»

### Authentication

Use a dedicated service user + Application Password:

```bash
# Sanity check your creds
curl -u "sync-bot:APPLICATION-PASSWORD" https://example.com/wp-json/

# Example POST (Series)
curl -u "sync-bot:APPLICATION-PASSWORD" \
     -H "Content-Type: application/json" \
     -X POST https://example.com/wp-json/four12/v1/series-sync \
     -d '{"sku":"SER-001","fields":{"post_title":"My Series"}}'
```

**Permission check**: the plugin requires `current_user_can('edit_posts')`. If you get `403`, check the user role.

â¸»

### Shared request shape (CPT endpoints)

All post-based modules accept:

```json
{
  "sku": "YOUR-STABLE-ID",                  // required
  "fields": { /* payload keys (see modules) */ },  // required
  "wp_id": 123,                             // optional, fast-path update
  "airtableRecordId": "recXXXX"             // optional, for logging
}
```

*	**Identity resolution**: `wp_id` â†’ `sku` â†’ `slug` (from `fields.post_name`), first match wins.
*	**Deletes**: set a key to `null` to delete it. Omitted keys are ignored (no change).
*	**Post status**: allowed values = `publish`, `draft`, `private`, `trash`.

**Special fields** handled by the base class:
*	`post_title`, `post_name` (slug), `post_excerpt`, `post_date`, `post_status`
*	`custom_permalink_uri` (if Permalink Manager is active)
*	`_thumbnail_id` (ID or URL â€” URL triggers sideload)
*	`_aioseo_description` (native AIOSEO write if available; meta fallback)

**Markdown mapping** (when Parsedown is present):
*	Modules can declare which incoming keys are markdown and where to save the rendered HTML (e.g., `post_content`, or a meta field).

â¸»

### Endpoints (modules) at a glance

#### 1) Series â€” `POST /wp-json/four12/v1/series-sync`
*	**CPT**: `series`
*	**Core fields**: `post_title`, `post_name`, `post_excerpt`, `post_date`, `post_status`, `custom_permalink_uri`
*	**Taxonomies**:
	*	`global-categories` â†’ `global-categories`
	*	`series-categories` â†’ `series-categories`
	*	`topics` â†’ `topics`
	*	`series-templates` â†’ `series-templates`
*	**Media meta** (ID or URL): `_thumbnail_id`, `listing-image`, `no-words-image`, `banner-image`, `manual1-image`
*	**Markdown**: `series_description` â†’ writes to both `post_content` and `series_description` (meta)

**Example payload**

```json
{
  "sku": "SER-001",
  "fields": {
    "post_title": "Ephesians Series",
    "post_name": "ephesians-series",
    "post_status": "publish",
    "post_date": "2024-06-01",
    "custom_permalink_uri": "resources/series/ephesians-series",
    "series_description": "# Welcome\n**Strong** foundations.",
    "global-categories": ["Worship > Songs", "Teaching"],
    "_thumbnail_id": "https://cdn.example.com/imgs/series-cover.jpg",
    "_aioseo_description": "A Bible teaching series on Ephesians."
  }
}
```

â¸»

#### 2) Sessions â€” `POST /wp-json/four12/v1/sessions-sync`
*	**CPT**: `resources`  â† (Yes, sessions live in the `resources` post type)
*	**Core fields**: `post_title`, `post_name`, `post_excerpt`, `post_date`, `post_status`
*	**Taxonomies**: `global-categories`, `series-categories`, `topics`, `series-templates`, `author-speaker` â†’ `author_speaker`
*	**Media meta**: `_thumbnail_id`, `listing-image`, `no-words-image`, `banner-image`, `manual1-image`
*	**Markdown**: `session_description_admin` â†’ `post_content`
*	**JetEngine relation** (Session â†’ Series parent):
	*	Payload key: `jet_relation_series_parent`
	*	Value: a Series SKU (string) or an array of SKUs
	*	Empty or `null` disconnects all parents
	*	Relation config: `relation_id: 63`, parent CPT `series`, parent SKU meta `sku`

**Example payload**

```json
{
  "sku": "SES-1001",
  "wp_id": 0,
  "fields": {
    "post_title": "Ephesians 1: Our Calling",
    "post_name": "ephesians-1-our-calling",
    "post_status": "publish",
    "post_date": "2024-06-07T09:30:00Z",
    "author-speaker": ["Andrew Selley"],
    "topics": "Identity, Grace",
    "_thumbnail_id": "https://cdn.example.com/sessions/ep1.jpg",
    "session_description_admin": "## Notes\n- Chosen\n- Adopted",
    "jet_relation_series_parent": "SER-001"
  }
}
```

â¸»

#### 3) Worship â€” `POST /wp-json/four12/v1/worship-sync`
*	**CPT**: `songs`
*	**Core fields**: `post_title`, `post_name`, `post_excerpt`, `post_date`, `post_status`
*	**Taxonomies**:
	*	`worship_artist` â†’ `worship-artist`
	*	`topics` â†’ `topics`
	*	`global-categories` â†’ `global-categories`
*	**Media meta**: `_thumbnail_id`, `chord_sheet_pdf` (URLs are sideloaded; attachment ID is stored)
*	**Other handy meta**: `apple_music_link`, `spotify_link`, `youtube_music_link` (saved as plain meta)
*	**Markdown**: none by default

**Example payload**

```json
{
  "sku": "W0036",
  "fields": {
    "post_title": "O You Are Beautiful",
    "post_name": "o-you-are-beautiful",
    "post_status": "publish",
    "post_date": "2018-03-30",
    "worship_artist": ["Mervis"],
    "topics": "Chords, Lyrics",
    "_thumbnail_id": "https://cdn.example.com/covers/o-you-are-beautiful.jpg",
    "chord_sheet_pdf": "https://cdn.example.com/chords/o-you-are-beautiful.pdf",
    "apple_music_link": "https://music.apple.com/za/album/...",
    "_aioseo_description": "A worship song by Mervis with chords and lyrics."
  }
}
```

â¸»

#### 4) Leaders â€” `POST /wp-json/four12/v1/leader-sync`
*	**CPT**: `f12-leaders`
*	**Core fields**: `post_title`, `post_excerpt`
*	**Taxonomies**: `leadership-role` â†’ `leadership-role`
*	**Media meta**: `_thumbnail_id`
*	**Markdown** (module-specific):
	*	If you pass `leader_description` (markdown) in `fields`, the module converts it to HTML and stores it in the `leader_description` meta.
	*	The raw key is then removed from the payload to avoid double-processing.

**Example payload**

```json
{
  "sku": "LEAD-042",
  "fields": {
    "post_title": "Jane Doe",
    "post_excerpt": "Elder, teacher, equipper.",
    "leadership-role": ["Elders"],
    "_thumbnail_id": "https://cdn.example.com/people/jane_doe.jpg",
    "leader_description": "### About Jane\nWalking with Jesus since 2009."
  }
}
```

â¸»

#### 5) Author/Speaker Taxonomy â€” `POST /wp-json/four12/v1/author-sync`
*	**Taxonomy**: `author_speaker`
*	**Request shape**:

```json
{
  "sku": "AUTH-001",
  "fields": {
    "name": "Andrew Selley",
    "slug": "andrew-selley",
    "as_description": "Bio in **markdown** or HTML",
    "status": "active",
    "profile_image": "https://cdn.example.com/author/andrew.png"
  },
  "wp_id": 0
}
```

*	**Required field**: `fields.name`
*	**Identity resolution**: `wp_id` â†’ `sku` â†’ `slug`
*	**Description handling**: prefer `as_description`; if Present + Parsedown available â†’ convert markdown â†’ term meta `as_description` (safe HTML). Otherwise stores text/HTML as given.
*	**Meta whitelist** (only these are written): `profile_image`, `status`
(Unknown keys are ignored and reported via logs; send `null` to delete a whitelisted key.)

â¸»

### Behavior details that matter
*	**Idempotency**: same payload â†’ safe no-op; nothing magically disappears.
*	**Deletion semantics**: set a key to `null` to remove it:
	*	Meta: `{ "fields": { "custom_key": null } }` deletes that meta.
	*	Taxonomy: `""` or `null` clears terms for that taxonomy key.
	*	Featured image: `_thumbnail_id: null` removes thumbnail.
*	**Dates & timezone**: send ISO 8601 (`YYYY-MM-DD` or `YYYY-MM-DDTHH:mm:ss[Z]`). The plugin converts to site timezone and sets both `post_date` and `post_date_gmt` correctly (DST-safe).
*	**Permalinks**: if `custom_permalink_uri` is present and Permalink Manager is active, that URI is saved and `post_name` is not changed. Without Permalink Manager, use `post_name`.
*	**AIOSEO**: if `_aioseo_description` is present and AIOSEO is active, itâ€™s saved via the AIOSEO model; otherwise stored as post meta.

â¸»

### Common errors & fixes
*	**400 â€“ bad JSON / missing fields**
Ensure `Content-Type: application/json`. Include `sku` and `fields` (and `fields.name` for `author-sync`).
*	**403 â€“ forbidden**
The service user lacks `edit_posts` or the Application Password is wrong.
*	**409 â€“ conflict (wrong CPT)**
A `wp_id` points to a post of the wrong type for that endpoint. Fix the target or send the correct endpoint.
*	**Media sideload failed**
Check the URL is reachable and returns a valid `Content-Type`. PDFs/images are accepted via WordPressâ€™ `media_handle_sideload`.
*	**JetEngine not active**
Relationship payload keys are ignored if JetEngine/relations are unavailable. Activate JetEngine or remove the keys.

**Pro tip**: enable `WP_DEBUG_LOG` in `wp-config.php`. The plugin logs under the prefix `[Four12 Quick Sync]`.

â¸»

### Testing snippets (swap endpoint accordingly)

```bash
# Create/update a Series
curl -u "sync-bot:APP-PASS" -H "Content-Type: application/json" \
  -X POST https://example.com/wp-json/four12/v1/series-sync \
  -d '{"sku":"SER-TEST-1","fields":{"post_title":"Hello Series","post_status":"draft"}}'

# Link a Session to its Series (JetEngine)
curl -u "sync-bot:APP-PASS" -H "Content-Type: application/json" \
  -X POST https://example.com/wp-json/four12/v1/sessions-sync \
  -d '{"sku":"SES-TEST-1","fields":{"post_title":"Session 1","jet_relation_series_parent":"SER-TEST-1"}}'

# Create/update an Author/Speaker term
curl -u "sync-bot:APP-PASS" -H "Content-Type: application/json" \
  -X POST https://example.com/wp-json/four12/v1/author-sync \
  -d '{"sku":"AUTH-TEST","fields":{"name":"John Example","status":"active"}}'
```

â¸»

### Changelog (keep this short & useful)
*	**2.1.0** â€” Safer `wp_id` validation, explicit `409` for wrong CPT; AIOSEO integration; JetEngine relation helper; custom permalink support; markdown maps; media sideloading improvements; taxonomy normalization.
*	**2.0.0** â€” Initial modularization of Series, Sessions, Worship, Leaders; SKU-first idempotency.

â¸»

### Maintainers
*	Four12 Global â€” ops/content
*	Engineering â€” you (and Future You). Leave breadcrumbs.

â¸»

If you only remember one rule: **never ship to prod before youâ€™ve run the payload against staging and eyeballed the result.** Your future self will thank you.
</file>

<file path="quick-sync-plugin/modules/sessions-sync.php">
<?php
/**
 * Quick Sync Module: Sessions CPT
 *
 * Provides the specific configuration for syncing the 'sessions' Custom Post Type.
 * It inherits all universal processing logic (Timezone, AIOSEO, etc.)
 * from the F12_Quick_Sync_Module_Base class.
 */

if ( ! defined( 'ABSPATH' ) ) {
    exit; // Exit if accessed directly.
}

class F12_Sessions_Sync_Module extends F12_Quick_Sync_Module_Base {

    /**
     * Set up all configuration for the 'sessions' CPT.
     */
    protected function init() {
        // --- Core Configuration ---
        $this->cpt = 'resources';
        $this->endpoint_slug = 'sessions-sync';
        $this->sku_meta_key = 'sku';

        // --- Field Mapping ---
        $this->core_field_map = [
            'post_title'   => 'post_title',
            'post_name'    => 'post_name',
            'post_excerpt' => 'post_excerpt',
            'post_date'    => 'post_date',
            'post_status'  => 'post_status',
        ];

        $this->taxonomy_map = [
            'global-categories' => 'global-categories',
            'series-categories' => 'series-categories',
            'topics'            => 'topics',
            'series-templates'  => 'series-templates',
            'author-speaker'    => 'author_speaker',
        ];

        $this->image_meta_map = [
            '_thumbnail_id',
            'listing-image',
            'no-words-image',
            'banner-image',
            'manual1-image',
        ];

        // â”€â”€ JetEngine: Series (parent) â‡¢ Sessions (child) â”€â”€
        $this->jet_engine_relation_map = [
            'jet_relation_series_parent' => [
                'relation_id'      => 63,
                'parent_cpt'       => 'series',
                'parent_sku_meta'  => 'sku',
                // no 'mode' key â€” helper is hard-coded to replace
            ],
        ];

        // Markdown mapping configuration
        $this->markdown_map = [
            'session_description_admin' => ['post_content']
        ];

    }

}
</file>

<file path="quick-sync-plugin/f12-quick-sync.php">
<?php
/**
 * Plugin Name:       Four12 - Quick Sync Framework
 * Plugin URI:        https://four12global.com
 * Description:       A modular framework for syncing data from Airtable to WordPress CPTs and Taxonomies.
 * Version:           2.0.0
 * Author:            Four12 Global
 * Author URI:        https://four12global.com

 */

if ( ! defined( 'ABSPATH' ) ) {
    exit; // Exit if accessed directly.
}

define( 'F12_QUICK_SYNC_PATH', plugin_dir_path( __FILE__ ) );
define( 'F12_QUICK_SYNC_URL', plugin_dir_url( __FILE__ ) );


/**
 * Main plugin class to coordinate all modules.
 */
final class F12_Quick_Sync_Manager {

    private static $instance;
    private $modules = [];

    /**
     * Singleton instance.
     */
    public static function get_instance() {
        if ( null === self::$instance ) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    /**
     * Constructor.
     */
    private function __construct() {
        $this->load_dependencies();
        $this->instantiate_modules();
        add_action( 'rest_api_init', [ $this, 'register_rest_routes' ] );
    }

    /**
     * Load all required files.
     */
    private function load_dependencies() {
        require_once F12_QUICK_SYNC_PATH . 'core-helpers.php';
        require_once F12_QUICK_SYNC_PATH . 'module-base.php';
        
        // Load Parsedown library if it exists
        if ( file_exists( F12_QUICK_SYNC_PATH . 'vendor/parsedown/Parsedown.php' ) ) {
            require_once F12_QUICK_SYNC_PATH . 'vendor/parsedown/Parsedown.php';
        }

        // Autoload all modules from the /modules/ directory
        foreach ( glob( F12_QUICK_SYNC_PATH . 'modules/*.php' ) as $module_file ) {
            require_once $module_file;
        }
    }

    /**
     * Find and instantiate all declared module classes.
     */
    private function instantiate_modules() {
        $declared_classes = get_declared_classes();
        foreach ( $declared_classes as $class_name ) {
            if ( substr($class_name, -12) === '_Sync_Module' && class_exists($class_name) ) {
                $this->modules[ $class_name ] = new $class_name();
            }
        }
    }

    /**
     * Register REST API routes for each loaded module.
     */
    public function register_rest_routes() {
        foreach ( $this->modules as $module ) {
            if ( ! method_exists($module, 'get_endpoint_slug') || ! method_exists($module, 'handle_sync_request') ) {
                continue;
            }

            register_rest_route(
                'four12/v1',
                '/' . $module->get_endpoint_slug(),
                [
                    'methods'             => WP_REST_Server::CREATABLE, // 'POST'
                    'callback'            => [ $module, 'handle_sync_request' ],
                    'permission_callback' => 'f12_quick_sync_permission_check',
                    'args'                => $module->get_rest_api_args(),
                ]
            );
             f12_sync_log( 'Registered endpoint: /four12/v1/' . $module->get_endpoint_slug() );
        }
    }
}

// Initialize the plugin manager.
F12_Quick_Sync_Manager::get_instance();

/**
 * Load the JetEngine relationship helper once JetEngine is available.
 */
add_action( 'plugins_loaded', function () {
	// Bail if JetEngine isn't active (avoids fatals in staging without the plugin).
	if ( ! function_exists( 'jet_engine' ) ) {
		return;
	}

	// Already loaded?  Skip (prevents redeclare in tests/CLI).
	// This now checks for the correct, final function name.
	if ( function_exists( 'f12_set_relation_parent_by_sku' ) ) {
		return;
	}

	require_once __DIR__ . '/relations.php'; // <-- adjust path if you move the file
}, 20 ); // priority 20 : JetEngine boots at 10, so we're safely after it
</file>

<file path="quick-sync-scripts/src/lib/media-helpers.ts">
/*********************************************************************
 * media-helpers.ts  â€“  shared â€œstepÂ 1â€ imageâ€‘sync utilities
 *
 * Usage in an entry file (e.g. seriesâ€‘media.ts):
 *
 *   import { mediaSync } from './lib/media-helpers';
 *
 *   mediaSync({
 *     airtableTable: 'Series',
 *     imageFields: IMAGE_FIELDS,
 *     envMediaEndpoints: {
 *       prod:    'https://four12global.com/wp-json/wp/v2/media',
 *       staging: 'https://wordpress-1204105-5660147.cloudwaysapps.com/wp-json/wp/v2/media',
 *     },
 *     lastModifiedField:  'media_last_modified',
 *     publishTimestampField: 'media_publish_timestamp',
 *   });
 *********************************************************************/

import { buildBasicAuth } from './sync-helpers';          // already exists

/* =========  Small helpers ========= */
const log = (msg: unknown) =>
  console.log(`[${new Date().toISOString()}]`, msg);  // â† identical to sync-helpers

/**
 * Fetches table schema to create a map of Field ID -> Field Name
 * for improved error logging.
 */
async function buildFieldIdToNameMap(table: any): Promise<Map<string, string>> {
  const idToNameMap = new Map<string, string>();
  // The table object has a 'fields' property which is an array of field objects
  if (table.fields && Array.isArray(table.fields)) {
    for (const field of table.fields) {
      if (field.id && field.name) {
        idToNameMap.set(field.id, field.name);
      }
    }
  }
  return idToNameMap;
}

/* =========  Types  ========= */
export interface ImageFieldConfig {
  /** Airtable attachment field (array of objects with .url)              */
  attachmentField:      string;
  /** Field that stores WP media ID(s) (â€œ123, 456â€)                        */
  wpIdField:            string;
  /** Field that stores WP media URL(s)                                    */
  wpUrlField:           string;
  /** Cache of the original Airtable attachment ID(s); lets us detect a changed img  */
  airtableCacheField:   string;
  /** Optional Airtable text field for external URL                        */
  externalUrlField?:    string;
  /** Multiâ€‘upload?  DefaultÂ false (= single attachment)                   */
  isMultiple?: boolean;
}

export interface MediaSyncConfig {
  airtableTable:          string;
  envMediaEndpoints:      Record<string, string>;  // keyed by `env` input
  imageFields:            ImageFieldConfig[];
  lastModifiedField:      string;                  // â€œmedia_last_modifiedâ€
  publishTimestampField:  string;                  // â€œmedia_publish_timestampâ€
  secretName?:            string;                  // default "APIâ€‘SYNC"
}

/* =========  Small helpers ========= */
const SECRET_DEFAULT = 'API-SYNC';

async function download(attachment: any) {
  const res = await fetch(attachment.url);
  if (!res.ok) throw new Error(`â†˜ download ${attachment.url} â†’ HTTP ${res.status}`);
  return {
    blob: await res.blob() as Blob,
    filename:  attachment.filename ?? 'file',
    contentType: res.headers.get('content-type') ?? 'application/octet-stream',
    srcUrl: attachment.url,
  };
}

async function uploadToWp(
  endpoint: string,
  basicAuth: string,
  { blob, filename, contentType }: { blob: Blob; filename: string; contentType: string },
  recordId?: string,
) {
  // Before you start an upload
  log(`Uploading ${filename}${recordId ? ` for record ${recordId}` : ''} â€¦`);

  try {
    const res = await fetch(endpoint, {
      method: 'POST',
      headers: {
        Authorization: `Basic ${basicAuth}`,
        'Content-Type': contentType,
        'Content-Disposition': `attachment; filename="${filename}"`,
      },
      body: blob,
    });
    const json = await res.json();
    if (!res.ok || !json?.id) {
      throw new Error(`â†— WP upload failed ${res.status}: ${JSON.stringify(json).slice(0,200)}`);
    }
    
    // Success
    log(`âœ… Uploaded ${filename} â†’ ${json.source_url} (wpId: ${json.id})`);
    
    return { id: String(json.id), url: json.source_url as string };
  } catch (err) {
    console.error(`âŒ Upload failed ${filename}${recordId ? ` for record ${recordId}` : ''}: ${(err as Error).message}`);
    throw err; // keep your upstream error handling intact
  }
}

/* =========  Fieldâ€‘byâ€‘field processor ========= */
async function processImageField(
  record: any,
  spec: ImageFieldConfig,
  wpEndpoint: string,
  basicAuth: string,
  recordId: string,
  onError?: (err: Error) => void,
) {
  const a = record.getCellValue(spec.attachmentField) ?? [];
  const prevWpIds   = (record.getCellValue(spec.wpIdField)  ?? '') as string;
  const prevWpUrls  = (record.getCellValue(spec.wpUrlField) ?? '') as string;
  const prevCacheIdsRaw = (record.getCellValue(spec.airtableCacheField) ?? '') as string;
  const prevIds = (prevCacheIdsRaw ?? '').split(',').filter(Boolean);
  const externalUrl = spec.externalUrlField
    ? (record.getCellValueAsString?.(spec.externalUrlField) || '').trim()
    : '';

  // If no attachments but an external link exists â†’ just use that
  if (a.length === 0 && externalUrl) {
    const changed = externalUrl !== prevWpUrls;
    return {
      wpIds:     null,
      wpUrls:    externalUrl,
      cacheUrls: null,
      changed,
    };
  }

  /* ----- No attachment?  Maybe clear stale WP refs ------ */
  if (a.length === 0) {
    if (prevWpIds || prevWpUrls || prevCacheIdsRaw) {
      return { wpIds: null, wpUrls: null, cacheUrls: null, changed: true };
    }
    return { changed: false };
  }

  /* ----- SINGLE attachment (99â€¯% of your useâ€‘cases) ----- */
  if (!spec.isMultiple) {
    const att = a[0];
    if (prevIds.includes(att.id) && prevWpIds) {
      log(`â†©ï¸ Reusing ${att.filename ?? 'file'} (wpId: ${prevWpIds})`);
      return { changed: false };
    }
    // New file or first run
    try {
      const { blob, filename, contentType } = await download(att);
      const { id, url } = await uploadToWp(wpEndpoint, basicAuth, { blob, filename, contentType }, recordId);
      return { wpIds: id, wpUrls: url, cacheUrls: att.id, changed: true };
    } catch (err) {
      if (onError) onError(err as Error);
      log(`âš ï¸  single-upload failed ${att.url}: ${(err as Error).message}`);
      return { changed: false };
    }
  }

  /* ----- MULTI attachment ----- */
  if (spec.isMultiple) {
    const uploads: Array<{id:string; url:string; airtableId:string}> = [];
    for (const at of a) {
      if (prevIds.includes(at.id)) {
        log(`â†©ï¸ Reusing ${at.filename ?? 'file'}â€¦`);
        continue;
      }
      try {
        const { blob, filename, contentType } = await download(at);
        const { id, url } = await uploadToWp(wpEndpoint, basicAuth, { blob, filename, contentType }, recordId);
        uploads.push({ id, url, airtableId: at.id });
      } catch (err) {
        if (onError) onError(err as Error);
        log(`âŒ  multiâ€‘upload failed ${at.url}: ${(err as Error).message}`);
      }
    }
    if (uploads.length || a.some((at: any) => prevIds.includes(at.id))) {
      // Collect everything you want to keep
      const keptIds   = a.filter((at: any) => prevIds.includes(at.id))
                         .map((at: any) => at.id);
      const keptWpIds = prevWpIds.split(',').filter(Boolean)
                         .filter((_, idx) => prevIds.includes(a[idx]?.id)); // crude but works
      const keptWpUrls = prevWpUrls.split(',').filter(Boolean)
                         .filter((_, idx) => prevIds.includes(a[idx]?.id)); // crude but works

      return {
        wpIds:     [...keptWpIds, ...uploads.map(u => u.id)].join(','),
        wpUrls:    [...keptWpUrls, ...uploads.map(u => u.url)].join(','),
        cacheUrls: [...keptIds ,  ...uploads.map(u => u.airtableId)].join(','),
        changed:   true,
      };
    }
    return { changed: false };
  }
  // fallback
  return { changed: false };
}

/* =========  Orchestrator ========= */
export async function mediaSync(cfg: MediaSyncConfig, inputConfig: any) {
  let hadErrors = false;
  const {
    airtableTable,
    envMediaEndpoints,
    imageFields,
    lastModifiedField,
    publishTimestampField,
    secretName = SECRET_DEFAULT,
  } = cfg;

  /* â€”â€” Inputs â€”â€” */
  const { recordId, env } = inputConfig;
  if (!recordId) throw new Error('Automation must pass {recordId}.');
  if (!env || !envMediaEndpoints[env]) {
    const availableEnvs = Object.keys(envMediaEndpoints).join(', ');
    throw new Error(`Input variable "env" is missing or invalid. Please provide one of the following: ${availableEnvs}`);
  }

  const wpEndpoint = envMediaEndpoints[env];
  const basicAuth  = buildBasicAuth(await input.secret(secretName), secretName);

  const table  = base.getTable(airtableTable);
  // --- NEW: Build the decoder map ---
  const fieldIdToNameMap = await buildFieldIdToNameMap(table);
  // ------------------------------------
  const fields = [
    lastModifiedField,
    publishTimestampField,
    ...imageFields.flatMap(f => [
      f.attachmentField,
      f.wpIdField,
      f.wpUrlField,
      f.airtableCacheField,
    ]),
  ];
  const rec = await table.selectRecordAsync(recordId, { fields });
  if (!rec) throw new Error(`Record ${recordId} not found.`);

  /* â€”â€” Shortâ€‘circuit if nothing changed â€”â€” */
  const lastMod  = rec.getCellValue(lastModifiedField)       as string | null;
  const lastSync = rec.getCellValue(publishTimestampField)   as string | null;
  if (lastMod && lastSync && Date.parse(lastMod) <= Date.parse(lastSync)) {
    log('â­Â Images unchanged since last sync â€“ skipping');
    return;
  }

  /* â€”â€” Process every image spec â€”â€” */
  const updates: Record<string, any> = {};
  let anyChanges = false;

  for (const spec of imageFields) {
    try {
      const r = await processImageField(rec, spec, wpEndpoint, basicAuth, recordId, (err) => { hadErrors = true; });
      if (r && r.changed) {
        updates[spec.wpIdField]          = r.wpIds   ?? null;
        updates[spec.wpUrlField]         = r.wpUrls  ?? null;
        updates[spec.airtableCacheField] = r.cacheUrls ?? null;
        anyChanges = true;
      }
    } catch (err) {
      hadErrors = true;
      log(`âš ï¸  Error processing field spec "${spec.attachmentField}": ${(err as Error).message}`);
    }
  }

  if (anyChanges) {
    if (!hadErrors) {
      updates[publishTimestampField] = new Date().toISOString();
    } else {
      log('âš ï¸  Skipping timestamp because at least one upload failed');
    }
    try {
      await table.updateRecordAsync(rec, updates);
      log('âœ…Â Media sync complete & fields updated');
    } catch (err) {
      const errorMessage = (err as Error).message;
      // --- NEW: Enhanced Error Logging ---
      const fieldIdMatch = errorMessage.match(/Field "(.+?)"/);
      if (fieldIdMatch && fieldIdMatch[1]) {
        const fieldId = fieldIdMatch[1];
        const fieldName = fieldIdToNameMap.get(fieldId) || 'Unknown Field';
        const enhancedMessage = `Error updating Airtable: The field "${fieldName}" (ID: ${fieldId}) could not accept the value provided by the script. Please verify its field type.`;
        log(`âŒ ${enhancedMessage}`);
        throw new Error(enhancedMessage);
      }
      log(`âŒ An unexpected error occurred while updating Airtable: ${errorMessage}`);
      throw err;
      // ------------------------------------
    }
  } else {
    log('âœ”Â No media changes detected â€“ nothing to write');
  }
}
</file>

<file path="quick-sync-plugin/module-base.php">
<?php
use AIOSEO\Plugin\Common\Models\Post as AioseoPost;

if ( ! defined( 'ABSPATH' ) ) {
    exit; // Exit if accessed directly.
}

abstract class F12_Quick_Sync_Module_Base {

    // --- Configuration to be set by child modules ---
    protected $cpt;
    protected $endpoint_slug;
    protected $sku_meta_key;
    protected $core_field_map = [];
    protected $taxonomy_map = [];
    protected $image_meta_map = [];
    protected $post_content_key = null; // We no longer need this for markdown
    protected $allowed_post_statuses = ['publish', 'draft', 'trash', 'private'];
    protected bool $duplicate_post_content_to_meta = false;
    protected $markdown_map = [];
    private $processed_meta = [];
    
    /** @var array  Key = payload field, value = relation config */
    protected $jet_engine_relation_map = [];

    /**
     * Constructor to set up module-specific hooks.
     */
    public function __construct() {
        // Make JetEngine honour the site timezone for every datetime meta.
        add_filter( 'jet-engine/datetime/use-wp-date', '__return_true', 10, 2 );
        $this->init();
    }

    /**
     * Abstract init method for child classes to set properties and add hooks.
     */
    abstract protected function init();

    /**
     * Get the endpoint slug for the router.
     * @return string
     */
    public function get_endpoint_slug() {
        return $this->endpoint_slug;
    }

    /**
     * Define the expected REST API arguments.
     * @return array
     */
    public function get_rest_api_args() {
        return [
            'sku' => [
                'type'              => 'string',
                'required'          => true,
                'sanitize_callback' => 'sanitize_text_field',
                'description'       => esc_html__( 'Unique identifier for the item. Used for de-duplication.', 'f12-quick-sync' ),
            ],
            'fields' => [
                'type'              => 'object',
                'required'          => true,
                'description'       => esc_html__( 'Object containing item data fields to be synced.', 'f12-quick-sync' ),
            ],
            'airtableRecordId' => [
                'type'              => 'string',
                'required'          => false,
                'sanitize_callback' => 'sanitize_text_field',
                'description'       => esc_html__( 'Optional Airtable Record ID for logging and reference.', 'f12-quick-sync' ),
            ],
            'wp_id' => [
                'type'              => 'integer',
                'required'          => false,
                'sanitize_callback' => 'absint',
                'description'       => esc_html__( 'Optional WordPress Post/Term ID. If provided, used for a fast-path update.', 'f12-quick-sync' ),
            ],
        ];
    }

    /**
     * The main handler for the REST request.
     * This is the refactored logic from the original plugin.
     */
    public function handle_sync_request( WP_REST_Request $request ) {
        $json_params = $request->get_json_params();
    
        if ( null === $json_params ) {
            return new WP_Error( 'f12_bad_json', __( 'Invalid JSON body or Content-Type not application/json.', 'f12-quick-sync' ), [ 'status' => 400 ] );
        }
    
        $sku                 = isset( $json_params['sku'] ) ? sanitize_text_field( $json_params['sku'] ) : null;
        $fields_from_payload = isset( $json_params['fields'] ) ? $json_params['fields'] : null;
        $wp_id               = isset( $json_params['wp_id'] ) ? absint( $json_params['wp_id'] ) : 0;
        
        if ( empty( $sku ) ) {
            return new WP_Error( 'f12_missing_sku', __( 'Required top-level "sku" parameter is missing from JSON body.', 'f12-quick-sync' ), [ 'status' => 400 ] );
        }
        if ( empty( $fields_from_payload ) || ! is_array( $fields_from_payload ) ) {
            return new WP_Error( 'f12_invalid_fields', __( 'Required "fields" parameter is missing or not an object in JSON body.', 'f12-quick-sync' ), [ 'status' => 400 ] );
        }
        
        $payload = $fields_from_payload; // No more apply_filters here
        $changed_summary = [ 'core' => [], 'meta' => [], 'taxonomy' => [], 'permalink' => [], 'special' => [] ];
    
        
        // Leave last_synced untouched; JetEngine will translate this UTC timestamp to local time when displaying.

        // ---- Find existing post ----
        $post = null;
        $mode = null;
    
        if ( $wp_id > 0 ) {
            $potential_post = get_post( $wp_id );
            
            // --- START of the MODIFICATION ---
            if ( $potential_post && $potential_post->post_type === $this->cpt ) {
                // This is the original, correct logic for a successful match.
                $existing_sku = get_post_meta( $potential_post->ID, $this->sku_meta_key, true );
                if ( empty($existing_sku) || $existing_sku === $sku ) {
                    $post = $potential_post;
                    $mode = 'update';
                    if (empty($existing_sku)) {
                        f12_sync_log( sprintf( 'Post found via wp_id %d and CLAIMED for SKU %s (was previously empty).', $post->ID, esc_html( $sku ) ) );
                    } else {
                        f12_sync_log( sprintf( 'Post found via fast-path wp_id: %d for CPT %s (SKU: %s)', $post->ID, $this->cpt, esc_html( $sku ) ) );
                    }
                } else {
                     f12_sync_log( sprintf( 'wp_id %d provided, but its SKU ("%s") does not match payload SKU ("%s"). Falling back to SKU lookup.', $wp_id, esc_html($existing_sku), esc_html( $sku ) ) );
                }
            } else if ( $potential_post && $potential_post->post_type !== $this->cpt ) {
                // --- THIS IS THE NEW, SAFER LOGIC ---
                // A post was found, but it's the wrong type. This is a fatal config error.
                $error_msg = sprintf(
                    'A post was found for wp_id %d, but its type ("%s") does not match the configured type ("%s") for this endpoint. Please correct the CPT slug in your PHP module.',
                    $wp_id,
                    $potential_post->post_type,
                    $this->cpt
                );
                f12_sync_log('[FATAL] ' . $error_msg);
                // Return a 409 Conflict error, as the payload data conflicts with server configuration.
                return new WP_Error( 'f12_cpt_mismatch', $error_msg, [ 'status' => 409 ] );
                // --- END OF THE NEW LOGIC ---
            } else {
                // The original fallback for when the wp_id doesn't exist at all.
                f12_sync_log( sprintf( 'wp_id %d provided, but no post was found. Falling back to SKU lookup.', $wp_id ) );
            }
            // --- END of the MODIFICATION ---
        }
    
        if ( ! $mode ) {
            $post = f12_get_post_by_sku( $sku, $this->cpt, $this->sku_meta_key );
            $mode = $post ? 'update' : 'create';
        }
    
        $post_id = ( 'update' === $mode && $post ) ? $post->ID : 0;
        
        // ---- Process and Save ----
        $post_data = $this->_prepare_core_data( $payload, $sku, $changed_summary );
        
        $post_id_after_save = $this->_save_core_post( $post_id, $mode, $post_data, $sku );
    
        if ( is_wp_error( $post_id_after_save ) ) {
            f12_sync_log( 'Error saving post (core fields) for SKU: ' . esc_html( $sku ) . '. Mode: ' . $mode . '. Error: ' . $post_id_after_save->get_error_message() );
            return $post_id_after_save;
        }
        $post_id = (int) $post_id_after_save;
    
        // Process remaining fields
                $this->_process_permalink( $post_id, $payload, $sku, $changed_summary );
        $this->_process_taxonomies( $post_id, $payload, $sku, $changed_summary );
        $this->_process_special_fields( $post_id, $payload, $sku, $changed_summary ); // This now handles AIOSEO universally
        $this->_process_jet_engine_relations( $post_id, $payload, $sku, $changed_summary );
        $this->_process_meta_fields( $post_id, $payload, $sku, $changed_summary );

        // ---- Prepare and return response ----
        $action = ( 'create' === $mode ) ? 'created' : 'updated';
        // Retrieve the post title for the response
        $post_obj = get_post( $post_id );
        $post_title = $post_obj ? $post_obj->post_title : '';
        $response_data = [
            'post_id'    => $post_id,
            'action'     => $action,
            'sku'        => $sku,
            'post_title' => $post_title,
            'message'    => sprintf(
                "%s '%s' successfully %s.",
                ucfirst( $this->cpt ),        // â€œSeriesâ€
                esc_html( $post_title ),      // â€œRegional Equip Gautengâ€
                $action                       // â€œupdatedâ€ (or â€œcreatedâ€ etc)
            ),
        ];
    
        return rest_ensure_response( $response_data );
    }


    /**
     * Prepares the $post_data array for wp_insert/update_post.
     */
    protected function _prepare_core_data( &$payload, $sku, &$changed_summary ) {
        $post_data = [ 'post_type' => $this->cpt ];
        $post_data['post_status'] = 'publish'; // Default

        // Standard core fields
        foreach ( $this->core_field_map as $payload_key => $wp_post_field_key ) {
            if ( array_key_exists( $payload_key, $payload ) ) {

                // Short-circuit the native slug update if a custom permalink is being used.
                if ( $wp_post_field_key === 'post_name' && isset($payload['custom_permalink_uri']) && !empty(trim($payload['custom_permalink_uri'])) && class_exists('Permalink_Manager_URI_Functions') ) {
                    f12_sync_log(sprintf('Core Field Processing: Skipping direct update of native "post_name" because "custom_permalink_uri" is provided for Permalink Manager. (SKU: %s)', esc_html($sku)));
                    if (!in_array('custom_permalink_uri', $changed_summary['permalink'])) {
                        $changed_summary['permalink'][] = 'custom_permalink_uri'; // Log permalink change intent
                    }
                    unset( $payload[ $payload_key ] ); // Remove post_name from further processing
                    continue; // Skip to the next field in the loop
                }

                $value = $payload[ $payload_key ];

                if ( 'post_date' === $wp_post_field_key && ! empty( $value ) ) {
                    // --- parse incoming string ---------------------------------------------
                    $dt_local = new DateTime( $value );          // honours the â€œZâ€ (UTC)
                    // ðŸš¨ ALWAYS convert to site timezone â€“ no conditions
                    $dt_local->setTimezone( wp_timezone() );     // now site time

                    $post_data['post_date']      = f12qs_mysql_local( $dt_local );
                    $post_data['post_date_gmt']  = f12qs_mysql_gmt(   $dt_local );
                } elseif ( 'post_status' === $wp_post_field_key ) {
                    if ( !empty($value) && is_string($value) && in_array( strtolower( $value ), $this->allowed_post_statuses, true ) ) {
                        $post_data[ $wp_post_field_key ] = strtolower( $value );
                    }
                } else {
                    $post_data[ $wp_post_field_key ] = $value;
                }
                
                if ( ! in_array( $payload_key, $changed_summary['core'] ) ) $changed_summary['core'][] = $payload_key;
                unset( $payload[ $payload_key ] );
            }
        }
        
        // --- Markdown processing (declarative) ---
        if ( ! empty( $this->markdown_map ) && class_exists('Parsedown') ) {
            $parser = Parsedown::instance()->setSafeMode(true);

            foreach ( $this->markdown_map as $source_key => $destinations ) {
                if ( ! array_key_exists( $source_key, $payload ) ) {
                    continue;
                }

                $raw_markdown = $payload[ $source_key ];
                $html = is_string( $raw_markdown ) ? wp_kses_post( $parser->text( $raw_markdown ) ) : '';

                foreach ( (array) $destinations as $dest_key ) {
                    if ( $dest_key === 'post_content' ) {
                        $post_data['post_content'] = $html;
                    } else {
                        $this->processed_meta[ $dest_key ] = $html;
                    }
                }

                unset( $payload[ $source_key ] );
                if ( ! in_array( "markdown_parsed:{$source_key}", $changed_summary['special'] ) ) {
                    $changed_summary['special'][] = "markdown_parsed:{$source_key}";
                }
            }
        }

        // If neither post_date nor post_date_gmt set above, default to now.
        if ( empty( $post_data['post_date'] ) ) {
            $now_local = f12qs_now();
            $post_data['post_date']     = f12qs_mysql_local( $now_local );
            $post_data['post_date_gmt'] = f12qs_mysql_gmt(   $now_local );
        }

        return $post_data;
    }

    /**
     * Saves the core post data.
     */
    protected function _save_core_post( $post_id, $mode, $post_data, $sku ) {
        if ( 'create' === $mode ) {
            return wp_insert_post( $post_data, true );
        } else {
            $post_data['ID'] = $post_id;
            return wp_update_post( $post_data, true );
        }
    }

    /**
     * Handles custom permalink integration.
     */
    protected function _process_permalink( $post_id, &$payload, $sku, &$changed_summary ) {
        if ( ! class_exists('Permalink_Manager_URI_Functions') || ! isset($payload['custom_permalink_uri']) ) {
            return;
        }

        $custom_uri = trim($payload['custom_permalink_uri']);
        if ( !empty($custom_uri) ) {
            $new_uri = ltrim($custom_uri, '/');
            if (substr($new_uri, -1) !== '/') $new_uri .= '/';

            if ($new_uri !== '/') {
                $save_result = Permalink_Manager_URI_Functions::save_single_uri($post_id, $new_uri, false, true);
                if ($save_result === true || $save_result === 1) {
                    f12_sync_log(sprintf('Permalink Manager: Success for post ID %d, URI "%s" (SKU: %s)', $post_id, esc_html($new_uri), esc_html($sku)));
                    if (!in_array('custom_permalink_uri', $changed_summary['permalink'])) $changed_summary['permalink'][] = 'custom_permalink_uri';
                }
            }
        }
        unset($payload['custom_permalink_uri']);

        // Prevent native post_name from being processed if a custom permalink was handled.
        if (isset($this->core_field_map['post_name'])) {
            unset($payload['post_name']);
        }
    }

    /**
     * Handles all taxonomy assignments.
     */
    protected function _process_taxonomies( $post_id, &$payload, $sku, &$changed_summary ) {
        foreach ( $this->taxonomy_map as $payload_key => $taxonomy_slug ) {
            if ( ! array_key_exists( $payload_key, $payload ) ) continue;

            $raw_term_values = $payload[ $payload_key ];
            
            if ( $raw_term_values === null || $raw_term_values === '' ) {
                wp_set_post_terms( $post_id, [], $taxonomy_slug, false );
                if ( ! in_array( $payload_key, $changed_summary['taxonomy'] ) ) $changed_summary['taxonomy'][] = $payload_key;
                unset( $payload[ $payload_key ] );
                continue;
            }

            // ... [Identical hierarchy logic from original file] ...
            $term_input_sets = [];
            $temp_term_list = is_array($raw_term_values) ? array_map('strval', $raw_term_values) : array_map('trim', explode(',', $raw_term_values));

            foreach( $temp_term_list as $term_entry_str ) {
                $term_entry_str = trim($term_entry_str);
                if (empty($term_entry_str)) continue;
                if (strpos($term_entry_str, '>') !== false) {
                    $term_input_sets[] = array_map('trim', explode('>', $term_entry_str));
                } else {
                    $term_input_sets[] = [$term_entry_str];
                }
            }

            $term_ids_to_set = [];
            if ( ! empty( $term_input_sets ) ) {
                foreach ($term_input_sets as $hierarchical_term_parts) {
                    $parent_id = 0;
                    foreach ($hierarchical_term_parts as $term_part_name) {
                        $term = term_exists( $term_part_name, $taxonomy_slug, $parent_id );
                        if ( ! $term ) $term = term_exists( sanitize_title( $term_part_name ), $taxonomy_slug, $parent_id );
                        
                        $term_id = 0;
                        if ( ! $term ) {
                            $insert_args = ($parent_id > 0 && is_taxonomy_hierarchical($taxonomy_slug)) ? ['parent' => $parent_id] : [];
                            $new_term = wp_insert_term( $term_part_name, $taxonomy_slug, $insert_args );
                            if ( is_wp_error( $new_term ) ) {
                                f12_sync_log( 'Could not create term "' . $term_part_name . '": ' . $new_term->get_error_message() );
                                break; 
                            }
                            $term_id = (int) $new_term['term_id'];
                        } else {
                            $term_id = (int) $term['term_id'];
                        }
                        
                        if ($term_id > 0) {
                            $term_ids_to_set[] = $term_id;
                            $parent_id = $term_id;
                        } else {
                            break;
                        }
                    }
                }
            }

            $term_ids_to_set = array_unique(array_filter($term_ids_to_set));
            $term_result = wp_set_post_terms( $post_id, $term_ids_to_set, $taxonomy_slug, false );

            if (!is_wp_error($term_result)) {
                 if ( ! in_array( $payload_key, $changed_summary['taxonomy'] ) ) $changed_summary['taxonomy'][] = $payload_key;
            }
            unset( $payload[ $payload_key ] );
        }
    }
    
    /**
     * Processes special, universally handled fields like AIOSEO.
     */
    protected function _process_special_fields( $post_id, &$payload, $sku, &$changed_summary ) {
        // --- AIOSEO Description Handling (Universal) ---
        // Automatically process if the conventional payload key exists.
        if ( isset( $payload['_aioseo_description'] ) ) {
            
            $raw_desc = sanitize_textarea_field( $payload['_aioseo_description'] );
            
            if ( function_exists( 'aioseo' ) && class_exists( AioseoPost::class ) ) {
                try {
                    $seoPost = AioseoPost::getPost( (int) $post_id ) ?: AioseoPost::create( [ 'post_id' => (int) $post_id ] );
                    $seoPost->description = $raw_desc;
                    method_exists( $seoPost, 'save' ) ? $seoPost->save() : $seoPost->savePost();
                    f12_sync_log( "AIOSEO: description saved via model for post {$post_id}" );
                } catch ( Throwable $e ) {
                    f12_sync_log( 'AIOSEO ERROR: ' . $e->getMessage() . ' - falling back to update_post_meta' );
                    update_post_meta( $post_id, '_aioseo_description', $raw_desc );
                }
            } else {
                // Fallback if AIOSEO is not active
                update_post_meta( $post_id, '_aioseo_description', $raw_desc );
            }

            if ( ! in_array( '_aioseo_description (AIOSEO)', $changed_summary['special'] ) ) {
                $changed_summary['special'][] = '_aioseo_description (AIOSEO)';
            }
            // Unset the key so it's not processed again in the generic meta loop.
            unset( $payload['_aioseo_description'] );
        }
    }

    /**
     * Hook for child modules to perform special meta field processing.
     * This method is called before the generic meta loop.
     * Child classes should unset any keys they handle to prevent double processing.
     */
    protected function _process_special_meta_fields( $post_id, &$payload, $sku, &$changed_summary ) {
        // Child modules can override this.
    }

    /**
     * Handles all remaining fields as post meta, including image sideloading.
     */
    protected function _process_meta_fields( $post_id, &$payload, $sku, &$changed_summary ) {
        // Always ensure SKU meta is correct
        if ( get_post_meta( $post_id, $this->sku_meta_key, true ) !== $sku ) {
            update_post_meta( $post_id, $this->sku_meta_key, $sku );
        }
        unset($payload[$this->sku_meta_key]);

        // --- Save processed markdown meta first ---
        if ( ! empty( $this->processed_meta ) ) {
            foreach ( $this->processed_meta as $meta_key => $html_value ) {
                update_post_meta( $post_id, $meta_key, $html_value );
                if ( ! in_array( "{$meta_key} (from markdown)", $changed_summary['meta'] ) ) {
                    $changed_summary['meta'][] = "{$meta_key} (from markdown)";
                }
            }
            $this->processed_meta = [];
        }

        // --- Call the hook for special handling ---
        $this->_process_special_meta_fields( $post_id, $payload, $sku, $changed_summary );
        // ---------------------------------------------

        foreach ( $payload as $meta_key => $meta_value ) {
            $meta_key_sanitized = sanitize_key( $meta_key );
            $processed_meta_value = $meta_value;

            // JetEngine last_synced field: always use UTC timestamp
            if ($meta_key_sanitized === 'last_synced') {
                if ($meta_value instanceof DateTime) {
                    $processed_meta_value = f12qs_unix_utc($meta_value);
                } elseif (is_numeric($meta_value)) {
                    // Assume already a timestamp, but cast to int
                    $processed_meta_value = (int)$meta_value;
                } elseif (is_string($meta_value)) {
                    // Try to parse as date string
                    $dt = new DateTime($meta_value, wp_timezone());
                    $processed_meta_value = f12qs_unix_utc($dt);
                }
            }

            // Image handling
            if ( in_array( $meta_key, $this->image_meta_map, true ) ) {
                if ( is_string( $meta_value ) && filter_var( $meta_value, FILTER_VALIDATE_URL ) ) {
                    $image_desc = get_the_title( $post_id ) ?: $sku;
                    $attachment_id = f12_sideload_image_from_url( $meta_value, $post_id, $image_desc );
                    if ( ! is_wp_error( $attachment_id ) && $attachment_id > 0 ) {
                        $processed_meta_value = $attachment_id;
                        f12_sync_log(sprintf('Image Sideload Success for "%s". New ID: %d (SKU: %s)', $meta_key, $attachment_id, esc_html($sku)));
                    } else {
                        f12_sync_log(sprintf('Image Sideload Failed for "%s". Error: %s (SKU: %s)', $meta_key, is_wp_error($attachment_id) ? $attachment_id->get_error_message() : 'Unknown', esc_html($sku)));
                        continue; // Skip updating meta on failure
                    }
                }
            }

            // Featured Image special handling
            if ($meta_key_sanitized === '_thumbnail_id') {
                if ( !empty($processed_meta_value) && (int) $processed_meta_value > 0 ) {
                    set_post_thumbnail( $post_id, (int) $processed_meta_value );
                } else {
                    delete_post_thumbnail($post_id);
                }
            } else { // All other meta
                if ( $meta_value === null ) {
                    delete_post_meta($post_id, $meta_key_sanitized);
                } else {
                    update_post_meta( $post_id, $meta_key_sanitized, $processed_meta_value );
                }
            }
             if ( ! in_array( $meta_key, $changed_summary['meta'] ) ) $changed_summary['meta'][] = $meta_key;
        }
    }

    /**
     * Sync JetEngine relationships declared in $this->jet_engine_relation_map.
     */
    protected function _process_jet_engine_relations( int $child_id, array &$payload, $sku, array &$changed_summary ) {
        if ( empty( $this->jet_engine_relation_map ) || ! function_exists( 'f12_set_relation_parent_by_sku' ) ) {
            return;
        }

        foreach ( $this->jet_engine_relation_map as $payload_key => $cfg ) {
            if ( ! isset( $payload[ $payload_key ] ) ) {
                continue;
            }

            $raw_skus = $payload[ $payload_key ];
            $parent_sku_list = is_array( $raw_skus ) ? $raw_skus : array_map( 'trim', explode( ',', (string) $raw_skus ) );
            $parent_sku_list = array_filter( $parent_sku_list );

            // Get the relation object to handle disconnection.
            $rel = jet_engine()->relations->get_active_relations( $cfg['relation_id'] );
            if (!$rel) continue;

            if ( empty($parent_sku_list) ) {
                // Handle disconnection if payload sends an empty list.
                $rel->delete_rows( null, $child_id );
                f12_sync_log( "[JetEngine] Disconnected all parents from child={$child_id} due to empty payload." );
                $changed_summary['special'][] = "jet_rel_{$cfg['relation_id']}_disconnected";
            } else {
                // Call the high-level helper function to do all the work.
                $parent_sku = $parent_sku_list[0];
                $result = f12_set_relation_parent_by_sku( $child_id, $parent_sku, $cfg );

                if ( ! is_wp_error($result) ) {
                    $changed_summary['special'][] = "jet_rel_{$cfg['relation_id']}";
                }
            }

            unset( $payload[ $payload_key ] );
        }
    }
}
</file>

<file path="quick-sync-scripts/src/sessions-sync.ts">
import { quickSync } from './lib/sync-helpers';

const FIELD_MAP = {
  /* â”€â”€ Core WP fields â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  session_title:       'post_title',
  session_slug:        'post_name',
  session_description_admin: 'session_description_admin',
  excerpt:             'post_excerpt',

  /* Custom permalink (Permalink Manager / AIOSEO) */
  session_permalink:   '_custom_uri',
  _aioseo_description: '_aioseo_description',


  /* â”€â”€ SKU & Status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  session_sku:         'sku',
  website_status:      'post_status',

  /* â”€â”€ Taxonomies â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  topics_title:        'topics',
  speaker_title:       'author-speaker',
  series_category:     'series-categories',
  global_categories:   'global-categories',

  /* â”€â”€ ACTIVE media (prefer ID, fallback URL) â”€â”€â”€â”€ */
  featured_image: {
    airtableIdField:   'featured_image_wp_id',
    airtableLinkField: 'featured_image_link',
    wpKey: '_thumbnail_id',
  },
  listing_image: {
    airtableIdField:   'listing_image_wp_id',
    airtableLinkField: 'listing_image_link',
    wpKey: 'listing-image',
  },
  no_words_image: {
    airtableIdField:   'no_words_image_wp_id',
    airtableLinkField: 'no_words_image_link',
    wpKey: 'no-words-image',
  },
  banner_image: {
    airtableIdField:   'banner_image_wp_id',
    airtableLinkField: 'banner_image_link',
    wpKey: 'banner-image',
  },
  pdf_image_1: {
    airtableIdField:   'pdf_image_1_wp_id',
    airtableLinkField: 'pdf_image_1_link',
    wpKey: 'pdf-image-1',
  },
  pdf_image_2: {
    airtableIdField:   'pdf_image_2_wp_id',
    airtableLinkField: 'pdf_image_2_link',
    wpKey: 'manual2-image',
  },

  /* â”€â”€ Meta / Links / Podcast etc. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  pdf_title_1:          'custom-pdf-title-1',
  pdf_link_1:           'link_ten',
  pdf_title_2:          'custom-pdf-title-2',
  pdf_link_2:           'link_eleven',
  alt_link:             'link_five',
  youtube_link:         'link_one',
  vimeo_link:           'vimeo_link',
  spotify_podcast:      'spotify-podcast-link',
  apple_podcast:        'apple-podcast-link',

  /* â”€â”€ Timestamps (sync bookkeeping) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  publish_timestamp:    'last_published',

  /* â”€â”€ JetEngine relationship (Series parent SKU) â”€â”€ */
  series_sku:    'jet_relation_series_parent',
  series_wp_id:  'jet_relation_series_wp_id',
  series_title:  'jet_relation_series_title',
};

/* -------------------------------------------------
   The single, valid call to input.config() for the entire script run.
-------------------------------------------------- */
const scriptInput = input.config();

quickSync({
  /* ----- Airtable table name ----- */
  airtableTable: 'Sessions',                // Airtableâ€™s table name

  /* ----- Airtable field that holds your permanent SKU & title ----- */
  skuField:   'session_sku',
  titleField: 'session_title',

  /* ----- END per-CPT overrides ----- */
  fieldMap: FIELD_MAP,
  envEndpoints: {
    // NOTE: CPT slug on WP is â€œresourcesâ€, so the REST route reflects that.
    prod:    'https://four12global.com/wp-json/four12/v1/sessions-sync',
    staging: 'https://wordpress-1204105-5660147.cloudwaysapps.com/wp-json/four12/v1/sessions-sync',
  },
}, scriptInput);
</file>

</files>
